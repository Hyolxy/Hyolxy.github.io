<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Markdown使用笔记]]></title>
    <url>%2F2018%2F03%2F31%2FMarkdown%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Hexo下使用的MarkDown为Github的GFM，风格很漂亮，简洁美观大方。但是GFM 的MarkDown语法和标准 的MarkDown稍有不同，使用过程中需要注意一些 概要介绍Markdown 是一种轻量级的「标记语言」，优点在于 专注你的文字内容而不是排版样式。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 可读，直观。适合所有人的写作语言。 语法简明概述 分段 两个回车 换行 两个空格 或者 回车 标题 # ~ ######，#号的个数表示几级标题，即表示一级标题到六级标题 强调 **文字** ， __文字__ ， _文字_ ， *文字* ， 文字 模块引用 &gt; 注意后面紧跟个空格 表格 - 和 | 分割行和列 ， : 控制对其方式 代码块 `四个空格 开头或， 使用三个点+代码内容+三个点 链接 [文字](链接地址) 图片 ![图片说明](图片地址) ，地址可以是本地路劲，也可以是网络地址 列表 * ， + ， - ， 1. ，选其中之一，注意后面紧跟个空格 内容强调123字体 **加粗** 显示字体 *斜体* 显示字体 ***加粗并斜体*** 显示 加粗、斜体字体 加粗 显示字体 斜体 显示字体 加粗并斜体 显示 1234字体 __加粗__ 显示字体 _斜体_ 显示字体 ___加粗并斜体___ 显示组合 *__加粗并斜体__* 显示 字体 加粗 显示字体 斜体 显示字体 加粗并斜体 显示组合 加粗并斜体 显示 列表无序代码:1234- 文本1 * 二级文本- 文本2- 文本3 效果如下： 文本1 二级文本 文本2 文本3 有序代码：123451. 文本1 1. 2121 2. 电影2. 文本23. 文本3 效果如下： 文本1 2121 电影 文本2 文本3 表1234| First Header | Second Header || ------------- | ------------- || Content Cell | Content Cell || Content Cell | Content Cell | 效果如下： First Header Second Header Content Cell Content Cell Content Cell Content Cell code两种方法： 在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以当前面有-的列表语句时，此时换成两个制表符就可以了 前后加(三个点点点)1234567891011- 填充(padding)元素内容与边框之间是可以设置距离的，称之为“填充”。填充也可分为上、右、下、左(顺时针)。 div&#123;padding:20px 10px 15px 30px;&#125;/*上、右、下、左(顺时针)，顺序不要搞混*/ div&#123; padding-top:20px; padding-right:10px; padding-bottom:15px; padding-left:30px; &#125; div&#123;padding:10px;&#125;/*上、右、下、左的填充都为10px;*/ div&#123;padding:10px 20px;&#125;/*上下填充一样为10px，左右一样为20px*/ 效果如下： 填充(padding)元素内容与边框之间是可以设置距离的，称之为“填充”。填充也可分为上、右、下、左(顺时针)。div{padding:20px 10px 15px 30px;}/*上、右、下、左(顺时针)，顺序不要搞混*/ div{ padding-top:20px; padding-right:10px; padding-bottom:15px; padding-left:30px; } div{padding:10px;}/*上、右、下、左的填充都为10px;*/ div{padding:10px 20px;}/*上下填充一样为10px，左右一样为20px*/ 图片Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式:行内式和参考式。 行内式的图片语法 12![Alt text](/path/to/img.jpg)//方括号里面放上图片的替代文字,接着的普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 &apos;title&apos; 文字![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 参考式的图片语法 1234![Alt text][id]//「id」是图片参考的名称，//图片参考的定义方式则和连结参考一样：[id]: url/to/image &quot;Optional title attribute&quot; 水平规则123456789Three or more...---Hyphens***Asterisks 效果如下： Three or more… Hyphens Asterisks 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;em&gt; 标签），你可以在星号的前面加上反斜杠：1\*literal asterisks\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：123456789101112\ 反斜线`` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 参考文章Markdown 语法说明(简体中文版) Markdown常用语法 | Xuan’s blog]]></content>
      <categories>
        <category>开发</category>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown的常用语法</tag>
        <tag>web基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用笔记]]></title>
    <url>%2F2018%2F03%2F31%2Fgit%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言本文对指令按照使用场景(建库，查看，修改，分支)进行分类归纳，介绍指令基本含义和用法，方便查阅。 工作区、版本库和暂存区 工作区：就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 暂存区：Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以,现在git commit就是往master分支上提交更改。简单理解:需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 本地库和远程库 新建仓库 建立远程库(为空，不要加README.md，不然后面会push不上去) 本地新建文件夹 git init初始化仓库，可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的。勿人为瞎改 远程库的名字就是origin，这是Git默认的叫法 git remote add origin git@github.com:michaelliao/learngit.git 这个命令是在本地的learngit仓库下执行的。这两个地方的仓库名不需要相同，因为会通过在本地的仓库目录下执行这条命令（命令中包含远程库的名字）已经将两者建立了联系 git push -u origin master 把本地库的所有内容推送到远程库上。把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数(推送和关联)，Git不但会把本地的master分支内容推送到远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 git push origin master每次本地提交后,推送最新修改到远程库 从远程库克隆假设github上面已经有一个远程库，但是本地没有，需要克隆到本地，远程库的名字叫gitskillsgit clone git@github.com:michaelliao/gitskills.git克隆一个本地库,则在当前文件夹下会多一个gitskills的文件夹cd gitskills进入克隆下来的本地库，默认的名字是和github上的一样的git push origin master 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上 常用查看指令 git status查看仓库当前的状态 git diff 文件名查看对文件做什么修改 git diff 版本号1 版本号2 --stat查看两个版本的差异的文件列表，包括被修改行数和增删图。参数改为--name-status前面显示修改说明字母(A,M等)，无行数 git log显示从最近到最远的提交日志 git log --pretty=oneline 简化日志输出的显示信息，commit id很长 git reflog 记录你的每一次命令，最先显示的是这个命令执行之后的版本的版本号的前七位，这样就算你清屏了或者重启了，也能找到某个版本的版本号，就可以轻松回退到那个版本 git branch 查看当前所在的分支。git branch命令会列出所有分支，当前分支前面会标一个*号 git log --graph --pretty=oneline --abbrev-commit用带参数的git log可以看到分支的合并情况。用git log --graph命令可以看到分支合并图 git remote 查看远程库的信息 git remote -v 显示更为详细的信息 常用修改指令 git add readme.txt添加，但是不提交 git commit -m &quot;提交描述&quot;提交，只有add后提交才有效。“改文件-&gt;add文件-&gt;再改-&gt;提交”，则第二次修改无效,不会被提交，只会成功提交第一次的修改。 修改commit版本中的注释修改已经commit版本里面的注释123456789//如果你的注释写错了$ git commit --amend//如果需要修改当前版本的倒数第二次状态$ git rebase --i HEAD~2//会出现pick:***的几行，将你要改的那行的pick改成edit然后退出//这时使用$ git log你会发现最上面的版本已经变成了你想改的那个$ git commit --amend//修改版本提交注释之后执行下面的就成功了$ git rebase --continue 撤销修改和版本回退 git checkout -- 文件名把没暂存(即没add)的干掉，或者说，丢弃工作区，回到到暂存状态 git reset HEAD 文件名把暂存的状态取消，工作区内容不变，但状态变为“未暂存”。简单来说，没有add过的修改，只需要git checkout -- 文件名即可撤销；add 过的修改，先git reset HEAD 文件名变成没add 过的修改，再git checkout -- 文件名撤销。 git reset --hard HEAD^会回退到上一个版本 git reset --hard 某版本号前几位通过命令行上的历史信息（假如你没清屏的话），找到某版本 的版本号回到指定版本。不一定要全部的版本号，就像这个命令的例子，只要前面的约7、8位这样就可以。 分支管理创建和合并分支 git checkout -b dev创建一个新的分支：dev，并且会切换到dev分支。所以这条命令有两个作用。git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：git branch dev和git checkout dev git branch dev，新建分支是新建指针,指向当前commit git checkout dev切换到dev分支 git checkout master dev分支的工作完成，我们就可以切换回master分支(此时在dev分支的修改在master上是看不到的) git merge dev这是在master分支上执行的命令，作用是：把dev分支上的工作成果合并到master分支上 git branch -d dev删除已合并的分支。删除分支就是删除指针 git branch -D devGit友情提醒，dev分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用git branch -D dev命令 参考链接刚学Git时在CSDN博客上发现一位大牛的Git学习总结，非常有用！！强烈推荐！！]]></content>
      <categories>
        <category>开发</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>git常用指令</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web开发学习笔记-Ajax笔记]]></title>
    <url>%2F2018%2F03%2F31%2Fweb%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Ajax%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这一篇是Ajax整理笔记 Ajax概要介绍 Ajax 是一种网页开发技术，（Asynchronous Javascript + XML）异步 JavaScript 和 XML； Ajax 是异步交互，局部刷新； Ajax 能减少服务器压力； Ajax 能提高用户体验；Ajax 交互与传统交互比较： 传统交互：网页整体刷新，服务器压力大，用户体验不好； Ajax交互：局部刷新，服务器压力小，用户体验好； 同步和异步为什么要用ajax，首先我们要了解同步和异步是什么. 同步的意思就是客户端提交表单，发起请求后需要一直等待服务器端的响应，收到服务器端的响应后需要重新载入页面。而有了ajax，则可进行异步交互，比如不会提交整个表单后等待服务器响应再刷新页面，而是填写的过程中，通过ajax的机制，就可以把已经填写的部分提交给服务器，服务器进行处理，而这个过程中可以继续填写后面的内容，服务器发送回响应只会刷新页面的部分内容（利用JavaScript操作DOM进行局部刷新），而不是重新载入整个页面。其实就是为客户机（网页中常为JavaScript）代码提供了一种发送HTTP请求的方式。通常提交请求都是以表单的形式发送，获取响应要刷新整页，而ajax则是按需发送，只刷新返回的数据。 Ajax的基本操作步骤Ajax指异步的JavaScript和XML，JS无需等待服务器响应，而是在继续执行脚本内容，响应就绪后对响应进行处理。若是同步，则JS代码会收到服务器的响应后再继续执行。ajax是通过XMLHttpRequest对象在客户端和服务器端进行数据交换的。 创建XMLHttpRequest对象该对象用于和服务器交换数据：123456789var xmlhttp;if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125;else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; 向服务器发送请求 XHR.open(method,url,async):规定请求的方式、请求文件在服务 器上的URL和是否异步处理请求。启动一个请求以备发送。 XHR.send()：将请求发送到服务器，参数为请求主体发送的数据，如果不需要请求主体发送数据，则必须填入null，因为对有些浏览器来说必须有一个参数。通常post方式会填入发送的数据。 详细步骤如下：（按顺序1&gt;2&gt;3） open(method,url,async)规定请求的类型、URL 以及是否异步处理请求函数内的参数分别代表：规定请求的类型、URL 以及是否异步处理请求。method：请求的类型；GET 或 POSTurl：文件在服务器上的位置async：true（异步）或 false（同步） setRequestHeader(header,value)向请求添加 HTTP 头。header: 规定头的名称value: 规定头的值 1xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); send(string)将请求发送到服务器。string：仅用于 POST 请求 服务器响应在收到响应后，响应的数据会自动填充XHR对象的属性：XHR.responseText：服务器返回的文本数据XHR.responseXML：服务器返回的XML格式的数据status：服务器返回的状态码。 响应的HTTP状态- 200: “OK”，响应成功返回- 304：请求的资源未被修改，可使用浏览器中的缓存版本- 404: 未找到页面同步的时候应当检查status的值后来决定下一步的操作： if(xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300 || xhr.status=304){ //do something }else{ alert(“request was unsuccessful: “+xhr.status); } 异步处理 onreadystatechange事件：当async为true时，规定该事件上绑定的方法，每当readyState属性改变时，就会触发该事件。 readyState属性：表示请求-响应过程的当前活动阶段。为XHR对象的状态。异步的时候应当检查该属性。从 0 到 4 发生变化: 0: 请求未初始化，未调用open() 1: 服务器连接已建立，已调用open，未调用send 2: 请求已接收，即服务器已收到请求头信息。 已调用send，尚未收到响应 3: 已收到部分响应数据 4: 请求已完成，已收到全部响应数据，可在客户端使用注意：需在调用open之前指定onreadystatechange事件绑定的函数才能确保跨浏览器兼容性。xhr.onreadystatechange=function(){ if(xhr.readyStatus==4){ if(xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300 || xhr.status==304){ //do something } else{ alert(&quot;request was unsuccessful: &quot;+xhr.status); } } }; 终止异步xhr.abort()：调用该方法取消异步请求，XHR对象会停止触发事件，并且不再允许访问任何与响应有关的对象属性。在终止请求后，应对XHR对象释放引用。 老版本的XHR对象缺点 只支持文本数据的传送，无法读取和上传二进制文件。 只能访问同域中的资源。 传送和接收数据时没有进度信息，只能提示有无完成。这里有：新版本即level2的改进 HTTP头部要想把ajax学得透彻，了解HTTP协议还是很有必要的。浏览器在发送XHR请求的同时也会默认发送一些头部信息，浏览器能够显示的字符集（Accept-charset）、当前页面设置的任何Cookie等。也可以自定义发送信息，通过调用XHR.setRequestHeader(header,value)向请求添加头部。该方法应当放在open之后send之前。XHR对象的getResponseHeader()和getAllResponseHeaders()可用于获取响应的头部信息 GET请求常用于向服务器查询某些信息，可将查询字符串参数追加到url末尾。必须对查询字符串进行encodeURIComponent()编码，具体来说必须对参数名和参数值都进行编码才能附加到url后面。向现有url追加查询字符串参数： 12345function addURLPara(url,name,value)&#123; url += (url.indexOf(&quot;?&quot;) == -1 ? &quot;?&quot;:&quot;&amp;&quot;); url += encodeURIComponent(name)+&quot;=&quot;+encodeURIComponent(value); return url;&#125; POST请求用于向服务器发送应当被保存的数据（修改服务器端数据），数据是请求的主体。什么时候使用POST方式？： 无法使用缓存文件（get通常会使用缓存？） 向服务器发送大量数据 发送包含未知字符的用户输入在send方法中传入要发送的数据（字符串或文档） 表单数据序列化通过XHR发送到服务器：12345678910111213141516function submitData()&#123; var xhr = createXHR(); xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; if(xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300 || xhr.status==304)&#123; //do something &#125;else&#123; alert(&quot;request was unsuccessful: &quot;+xhr.status); &#125; &#125;; &#125; xhr.open(&quot;post&quot;,&quot;url&quot;,true); xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); //表单提交时的内容类型，如果提交的是表单数据必须要写这个 var form = document.getElementById(&quot;user-info&quot;); xhr.send(serialize(form));//表单序列化&#125; 使用该方式必须设置自定义请求头部信息Content-Type，以说明请求的内容类型。这样服务器就会根据请求的内容类型来解析表单中的数据。在通过post方式请求表单中，在open和send之间，要添加request.setRequestHeader(“Content-Type”,”application/x-www-form-urlencoded”)如果不设置content-type头部，那么发送给服务器的数据就不会出现在$_POST超级全局变量中。 拾遗：GET 还是 POST？与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 异步 - True 或 False？AJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。 为 True 的话，表示的是异步，异步表示程序请求服务器的同时，程序可以继续执行；能提高系统的运行效率； 为 False 的话，表示同步，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。我们一般都是用 True；]]></content>
      <categories>
        <category>web开发</category>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>web基础</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web开发学习笔记-json笔记]]></title>
    <url>%2F2018%2F03%2F31%2Fweb%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-json%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文主要对Json基础知识进行介绍 JSON介绍json格式的引入： 一种轻量级的数据交换格式 JavaScript 对象表示法（JavaScript Object Notation）。 JSON 是存储和交换文本信息的语法，类似 XML。但是JSON 比 XML 更小、更快，更易解析。 百科：JSON的全称是”JavaScript Object Notation”，意思是JavaScript对象表示法，它是一种基于文本，独立于语言的轻量级数据交换格式。XML也是一种数据交换格式，为什么没有选择XML呢？因为XML虽然可以作为跨平台的数据交换格式，但是在JS(JavaScript的简写)中处理XML非常不方便，同时XML标记比数据多，增加了交换产生的流量，而JSON没有附加的任何标记，在JS中可作为对象处理，所以我们更倾向于选择JSON来交换数据。 格式JSON有两种表示结构，对象和数组。 对象结构该结构以”{”大括号开始，以”}”大括号结束。中间部分由0或多个以”，”分隔的”key(关键字)/value(值)”对构成，关键字和值之间以”：”分隔，语法结构如代码示例：1234JSON 对象&#123; &quot;name&quot;:&quot;张三&quot; , &quot;age&quot;:2 &#125; 其中关键字是字符串，而值可以是字符串，数值，true,false,null,对象或数组 数组结构数组结构以”[”开始，”]”结束。中间由0或多个以”，”分隔的值列表组成语法结构如下代码：12345678JSON 数组 &#123; &quot;student&quot;: [ &#123; &quot;name&quot;:&quot;张三&quot; , &quot;age&quot;:22 &#125;, &#123; &quot;name&quot;:&quot;李四&quot; , &quot;age&quot;:23 &#125;, &#123; &quot;name&quot;:&quot;王五&quot; , &quot;age&quot;:24 &#125; ] &#125; 两种格式嵌套时12345678JSON 嵌套 &#123; &quot;student&quot;: [ &#123; &quot;name&quot;:&quot;张三&quot; , &quot;age&quot;:22 ,&quot;score&quot;:&#123;&quot;chinese&quot;:90,&quot;math&quot;:100,&quot;english&quot;:80&#125; &#125;, &#123; &quot;name&quot;:&quot;李四&quot; , &quot;age&quot;:23 ,&quot;score&quot;:&#123;&quot;chinese&quot;:70,&quot;math&quot;:90, &quot;english&quot;:90&#125; &#125;, &#123; &quot;name&quot;:&quot;王五&quot; , &quot;age&quot;:24 ,&quot;score&quot;:&#123;&quot;chinese&quot;:80,&quot;math&quot;:60, &quot;english&quot;:90&#125; &#125; ] &#125; 这里我们常常需要了解以下知识：普通字符串，json字符串和json对象的区别。在js中： 字符串：这个很好解释，指使用“”双引号或’’单引号包括的字符。例如:var comStr = &#39;this is string&#39;; json字符串:指的是符合json格式要求的js字符串例如:var jsonStr = &quot;{StudentID:&#39;100&#39;,Name:&#39;tmac&#39;,Hometown:&#39;usa&#39;}&quot;; json对象:指符合json格式要求的js对象例如:var jsonObj = { StudentID: &quot;100&quot;, Name: &quot;tmac&quot;, Hometown: &quot;usa&quot; };把 Json 串 转换成 Json 对象:1var dataObj=eval(&quot;(&quot;+data+&quot;)&quot;);//转换为 json 对象 拾遗：当字符串中“ ”中还有引号。这个时候需要用转义符\1String resultJson=&quot;&#123;\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;age\&quot;:22&#125;&quot;; 引入JSON的Java包引入JSON的Java包来实现面向对象的方式来更加方便的定义使用JSON对象Json 第三方 jar 包引入:Json-lib1234567891011private void getJsonObject(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; PrintWriter out=response.getWriter(); // String resultJson="&#123;\"name\":\"张三\",\"age\":22&#125;";//不再使用这种不容易维护的写法 JSONObject resultJson=new JSONObject(); resultJson.put("name", "张三"); resultJson.put("age", 22); out.println(resultJson); out.flush(); out.close(); &#125; json实现单元格置表并输出1234567891011121314151617181920212223242526272829function loadInfo2()&#123; var xmlHttp; if(window.XMLHttpRequest)&#123; xmlHttp=new XMLHttpRequest(); &#125;else&#123; xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; xmlHttp.onreadystatechange=function()&#123; if(xmlHttp.readyState==4 &amp;&amp; xmlHttp.status==200)&#123; alert(xmlHttp.responseText); var dataObj=eval("("+xmlHttp.responseText+")"); var st=document.getElementById("studentTable"); alert(dataObj.students.length); var newTr; // 行 var newTd0; // 第一列 var newTd1; // 第二列 var newTd2; // 第三列 for(var i=0;i&lt;dataObj.students.length;i++)&#123; var student=dataObj.students[i]; newTr=st.insertRow(); newTd0=newTr.insertCell(); newTd1=newTr.insertCell(); newTd2=newTr.insertCell(); newTd0.innerHTML=student.name; newTd1.innerHTML=student.age; newTd2.innerHTML="语文:"+student.score.chinese+",数学:"+student.score.math+",英语:"+student.score.english; &#125; &#125; &#125;;]]></content>
      <categories>
        <category>web开发</category>
        <category>Json</category>
      </categories>
      <tags>
        <tag>web基础</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web开发学习笔记-CSS布局经典问题整理]]></title>
    <url>%2F2018%2F03%2F31%2Fweb%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-CSS%E5%B8%83%E5%B1%80%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"></content>
      <categories>
        <category>web开发</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>web基础</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web开发学习笔记-DOM基础篇]]></title>
    <url>%2F2018%2F03%2F31%2Fweb%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-DOM%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[本文主要介绍 HTML DOM。第一部分 “DOM 概述” 主要参考 MDN，第二部分 “HTML DOM” 主要参考 W3School。 DOM 概述文档对象模型 (DOM) 是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将web页面和脚本或程序语言连接起来。所有操作和创建web页面的属性，方法和事件都会被组织成对象的形式（例如， document 对象表示文档本身， table 对象实现了特定的 HTMLTableElement DOM 接口来访问HTML 表格等）。 JavaScript 可以访问和操作存储在 DOM 中的内容:API (web 或 XML 页面) = DOM + JS (脚本语言)一些重要的数据类型： document:每个载入浏览器的 HTML 文档都会成为 Document 对象。MDN - document element :element 是指由 DOM API 中成员返回的类型为 element 的一个元素或节点。 nodeList :nodeList 是一个元素的数组 attribute :DOM 中的属性也是节点，就像元素一样 namedNodeMap :namedNodeMap 和数组类似，但是条目是由 name 或 index 访问的 HTML DOM下面用一张树状图图来介绍 HTML DOM。文档对象模型 DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将 HTML 文档呈现为带有元素、属性和文本的树结构（节点树）HTML 文档可以说由节点构成的集合,常见的 DOM 节点: 元素节点：上图中&lt;html&gt;、&lt;body&gt;、&lt;p&gt;等都是元素节点，即标签 文本节点：向用户展示的内容，如 &lt;li&gt;...&lt;/li&gt;中的 JavaScript、DOM、CSS等文本。 属性节点：元素属性，如 &lt;a&gt; 标签的链接属性 href=&quot;http://www.imooc.com&quot;几个简单的 DOM 操作： innerHTML 属性用于获取或替换 HTML 元素的内容，Object.innerHTML 改变 HTML 样式，Object.style.property=new style; 隐藏和显示 Object.style.display = value，value 可取 none 或者 blockHTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法。换言之，HTML DOM 是关于如何获取、修改、添加或删除 HTML 元素的标准。参考 W3School - HTML DOM 教程 方法和属性所有 HTML 元素被定义为对象，而编程接口则是 对象方法 和 对象属性。 方法是您能够执行的动作（比如添加或修改元素）。 属性是您能够获取或设置的值（比如节点的名称或内容） 一些常用的 HTML DOM 方法： getElementById(id) - 获取带有指定 id 的节点（元素） appendChild(node) - 插入新的子节点（元素） removeChild(node) - 删除子节点（元素） 一些常用的 HTML DOM 属性： innerHTML - 节点（元素）的文本值 parentNode - 节点（元素）的父节点 childNodes - 节点（元素）的子节点 attributes - 节点（元素）的属性节点 nodeName - nodeName属性规定节点的名称。 nodeName 是只读的 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 与属性名相同 文本节点的 nodeName 始终是 #text 文档节点的 nodeName 始终是 #document nodeValue - 性规定节点的值。 元素节点的 nodeValue 是 undefined 或 null 文本节点的 nodeValue 是文本本身 属性节点的 nodeValue 是属性值 nodeType - 返回节点的类型。nodeType 是只读的。 DOM 根节点有两个特殊的属性，可以访问全部文档： document.documentElement - 全部文档 document.body - 文档的主体 访问和修改访问 HTML 元素等同于访问节点,能够以不同的方式来访问 HTML 元素： getElementById() 方法 getElementsByTagName() 方法 getElementsByClassName() 方法 修改 HTML DOM 意味着许多不同的方面： 改变 HTML 内容 改变 CSS 样式 改变 HTML 属性 创建新的 HTML 元素 删除已有的 HTML 元素 改变事件（处理程序） 事件HTML 事件的例子： 当用户点击鼠标时，onmousedown、onmouseup 以及 onclick事件 当网页已加载时，onload 和 onunload 事件 当图片已加载时 当鼠标移动到元素上时，onmouseover 和 onmouseout 事件 当输入字段被改变时，onchange 事件 当 HTML 表单被提交时 当用户触发按键时]]></content>
      <categories>
        <category>web开发</category>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>web基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web开发学习笔记-CSS基础篇]]></title>
    <url>%2F2018%2F03%2F31%2Fweb%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-CSS%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[本文主要对 CSS 相关基础知识进行介绍 基础知识CSS 样式由选择符和声明组成，而声明又由属性和值组成。 选择符：又称选择器，指明网页中要应用样式规则的元素。声明：在英文大括号{}中的的就是声明，属性和值之间用英文冒号{}分隔。当有多条声明时，中间可以英文分号;分隔。123选择器&#123; 样式;&#125; 从CSS 样式代码插入的形式来看基本可以分为以下3种：内联式、嵌入式和外部式三种。优先级遵循就近原则，一般来说，内联式 &gt; 嵌入式 &gt; 外部式。 内联式 例子 1&lt;p style="color:red;font-size:12px"&gt;这里文字是红色&lt;/p&gt; 嵌入式 示例12345&lt;style type="text/css"&gt; span&#123; color:red; &#125;&lt;/style&gt; 外部式 例子1&lt;link href=&quot;base.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; CSS 选择器 常见的类选择器类型有如下几种： 标签选择器 .标签选择器名称{css样式代码;} 类选择器 .类选器名称{css样式代码;} ID 选择器 ＃类选器名称{css样式代码;} 子选择器 即大于符号(&gt;),用于选择指定标签元素的第一代子元素 包含选择器 即加入空格 ,用于选择指定标签元素下的后辈元素 通用选择器 匹配html中所有标签元素， {css样式代码;}类选择器和ID选择器都可以应用于任何元素，但 ID 选择器只能在文档中使用一次，可以使用类选择器词列表方法为一个元素同时设置多个样式，ID 选择器是不可以的。子选择器和包含选择器区别：**&gt;*作用于元素的第一代后代，空格作用于元素的所有后代。 另外还有两种选择符： 伪类选择符允许给 HTML 不存在的标签（标签的某种状态）设置样式。常用的有 a:hover{color:red;} 分组选择符，为 HTML 中多个标签元素设置同一个样式时，可以使用分组选择符,。例如 h1,span{color:red;}CSS 的继承、层叠和特殊性 CSS 的某些样式是具有继承性的，继承是一种规则，它允许样式不仅应用于某个特定 HTML 标签元素，而且应用于其后代。 特殊性：不同选择器具有不同权值，标签的权值为 1，类选择符的权值为 10，ID选择符的权值最高为 100。 层叠 就是在 HTML 文件中对于同一个元素可以有多个 CSS 样式存在，当有相同权重的样式存在时，会根据这些 CSS 样式的前后顺序来决定，处于最后面的 CSS 样式会被应用。 CSS 格式化排版文字排版 字体，body{font-family:”Microsoft Yahei”;} 字号、颜色，body{font-size:12px;color:#666} 粗体，body{font-weight:bold;} 斜体，body{font-style:italic;} 下划线，body{font-style:italic;} 删除线，body{text-decoration:line-through;}段落排版 缩进，p{text-indent:2em;} 行间距（行高），p{line-height:1.5em;} 中文字间距、字母间距，letter-spacing:50px;和word-spacing:50px; 对齐，div{text-align:center;}CSS 盒模型元素分类在 CSS 中，HTML 中的标签元素大体被分为三种不同的类型：块状元素、内联元素(又叫行内元素)和内联块状元素。 常用的块状元素有：1&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt; 块级元素特点： 每个块级元素都从新的一行开始，并且其后的元素也另起一行。 元素的高度、宽度、行高以及顶和底边距都可设置。 元素宽度在不设置的情况下，是它本身父容器的 100%（和父元素的宽度一致），除非设定一个宽度。设置 display:block 就是将元素显示为块级元素，从而使元素具有块状元素特点。注：img 标签与 div 层之间会有空隙的解决方法是：使用 display:block 就可以消除间隙。 常用的内联元素有：1&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; 内联元素特点： 和其他元素都在一行上； 元素的高度、宽度及顶部和底部边距不可设置； 元素的宽度就是它包含的文字或图片的宽度，不可改变。块状元素也可以通过代码 display:inline 将元素设置为内联元素。 常用的内联块状元素有：1&lt;img&gt;、&lt;input&gt; inline-block 元素特点： 和其他元素都在一行上； 元素的高度、宽度、行高以及顶和底边距都可设置。内联块状元素（inline-block）就是同时具备内联元素、块状元素的特点，代码 display:inline-block 就是将元素设置为内联块状元素。盒模型 边框盒子模型的边框就是围绕着内容及补白的线，这条线你可以设置它的粗细、样式和颜色(边框三个属性)。12345678910div&#123; border:2px solid red;&#125;div&#123; border-width:2px; border-style:solid; border-color:red;&#125; 单独设置下边框的例子 div{border-bottom:1px solid red;} 宽度和高度CSS 内定义的宽（width）和高（height），指的是 填充以里的内容范围。一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。 W3C 的标准 Box Model:123456/*外盒尺寸计算（元素空间尺寸）*/Element空间高度 = content height + padding + border + marginElement 空间宽度 = content width + padding + border + margin/*内盒尺寸计算（元素大小）*/Element Height = content height + padding + border （Height为内容高度）Element Width = content width + padding + border （Width为内容宽度） 所以有时会设置 box-sizing: border-box; 来避免计算内部元素大小 填充(padding)元素内容与边框之间是可以设置距离的，称之为“填充”。填充也可分为上、右、下、左(顺时针)。div{padding:20px 10px 15px 30px;}/*上、右、下、左(顺时针)，顺序不要搞混*/ div{ padding-top:20px; padding-right:10px; padding-bottom:15px; padding-left:30px;} div{padding:10px;}/*上、右、下、左的填充都为10px;*/ div{padding:10px 20px;}/*上下填充一样为10px，左右一样为20px*/ 边界(margin) 元素与其它元素之间的距离可以使用边界（margin）来设置，顺序和填充一样是上，右，下，左。padding 在边框里，margin 在边框外。 CSS布局模型CSS 包含 3 种基本的布局模型，用英文概括为：Flow、Layer 和 Float。 在网页中，元素有三种布局模型： 流动模型（Flow） 浮动模型 (Float) 层模型（Layer）流动模型流动模型，流动（Flow）是默认的网页布局模式。流动布局模型具有2个比较典型的特征： 块状元素 都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为 100%。实际上，块状元素都会以行的形式占据位置。 在流动模型下，内联元素 都会在所处的包含元素内从左到右水平分布显示。 浮动模型任何元素在默认情况下是不能浮动的，但可以用 CSS 定义为浮动。例子：#div1{float:left;} 层模型CSS 定义了一组定位（positioning）属性来支持层布局模型。 层模型有三种形式： 绝对定位(position: absolute) 相对定位(position: relative) 固定定位(position: fixed)可参考这篇文章辅助理解 《css绝对定位、相对定位和文档流的那些事》 绝对定位(position: absolute)如果想为元素设置层模型中的绝对定位，需要设置 position:absolute(表示绝对定位)，这条语句的作用将元素从文档流中拖出来，然后使用 left、right、top、bottom 属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于 body 元素，即相对于浏览器窗口。 相对定位(position: relative)如果想为元素设置层模型中的相对定位，需要设置 position:relative（表示相对定位），它通过 left、right、top、bottom 属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按 static(float) 方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。简单来说，就是相对元素原来的位置进行移动，元素本身所占的位置会保留。 固定定位(position: fixed)设置 position:fixed;。fixed：表示固定定位，与 absolute 定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与 background-attachment:fixed; 属性功能相同。 Relative 与 Absolute 组合使用,必须遵守下面规范： 参照定位的元素必须是相对定位元素的前辈元素 参照定位的元素必须加入 position:relative; 定位元素加入 position:absolute，便可以使用 top、bottom、left、right 来进行偏移定位了 例子：HTML代码：123&lt;div id="box1"&gt;&lt;!--参照定位的元素--&gt;&lt;div id="box2"&gt;相对参照元素进行定位&lt;/div&gt;&lt;!--相对定位元素--&gt;`&lt;/div&gt; CSS代码：1234567891011#box1&#123; width:200px; height:200px; position:relative; /*参照定位的元素必须加入position:relative;*/ &#125;#box2&#123; position:absolute; top:20px; left:30px;/*定位元素加入position:absolute*/ &#125; 颜色和长度 设置颜色的方法也有很多种： 英文命令颜色，p{color:red;} RGB颜色，p{color:rgb(133,45,200);} 和 p{color:rgb(20%,33%,25%);} 十六进制颜色， 这种颜色设置方法是现在比较普遍使用的方法，其原理其实也是 RGB 设置，但是其每一项的值由 0-255 变成了十六进制 00-ff。p{color:#00ffff;}(当你设置的颜色是 16 进制的色彩值时，如果每两位的值相同，可以缩写一半，#0ff)RGB 配色表参考 RGB颜色对照表 - 在线工具 - 开源中国 或者 RGB 配色表长度单位总结一下，目前比较常用到px（像素）、em、% 百分比，要注意其实这三种单位都是相对单位。 像素 em，就是本元素给定字体的 font-size值 % 百分比 设置小技巧水平居中设置 行内元素。如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 text-align:center 来实现的。 定宽块状元素(块状元素的宽度 width为固定值)。满足定宽和块状两个条件的元素是可以通过设置“左右 margin”值为 auto 来实现居中的。 不定宽块状元素。*加入 table标签(包括 &lt;tbody&gt;、&lt;tr&gt;、&lt;td&gt;)，为这个 table 设置“左右 margin 居中” 设置 display: inline 方法：与第一种类似，显示类型设为 行内元素，然后使用 text-align:center来实现居中效果，进行不定宽元素的属性设置。 给父元素设置 float 和 position:relative; left:50%，子元素设置 position:relative和 left: -50% 来实现水平居中。垂直居中设置 父元素高度确定的单行文本。通过设置父元素的 height 和 line-height 高度一致来实现的。(height: 该元素的高度；line-height: 顾名思义，行高（行间距），指在文本中，行与行之间的 基线间的距离 )。 父元素高度确定的多行文本。使用插入 table (包括 tbody、tr、td)标签，同时设置 vertical-align：middle。另外，为元素设置以下两个属性之一会隐形改变 display 类型，元素的display显示类型就会自动变为以 display:inline-block（块状元素）的方式显示，当然就可以设置元素的 width 和 height 了，且默认宽度不占满父元素。 position: absolute float: left 或 float:right]]></content>
      <categories>
        <category>web开发</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>web基础</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web开发学习笔记-Html篇]]></title>
    <url>%2F2018%2F03%2F31%2Fweb%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Html%E7%AF%87%2F</url>
    <content type="text"><![CDATA[本文主要对 HTML 进行介绍和归纳。首先，我们要知道HTML是一种超文本标记语言，不需要编译，直接由浏览器执行。HTML由W3C维护，是通向WEB技术世界的钥匙。 一、HTML文件主体结构标签1、文档声明 &lt;!doctype html&gt;2、html标签3、head标签里面会包含诸如页面标题，搜索引擎信息等相关的标签4、body标签页面的主体内容包含在里面。属性有background、bgcolor、text、link、vlink、alink 二、head头部标签1、&lt;title&gt;&lt;/title&gt;定义标题2、&lt;meta/&gt;向服务器和客户端传达关于文档的隐藏信息。3、&lt;link href=&quot;&quot;&gt;&lt;/link&gt;允许当前文档和外部文档建立连接相关的代码： 定义字符集编码&lt;meta charset=&quot;utf-8&quot;&gt; 刷新或者跳转&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=http://www.baidu.com&quot; &gt;过3秒跳到百度 设置关键字&lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt; 设置页面描述&lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; 定义网站标题图标&lt;link rel=&quot;shortcut icon&quot; href=&quot;图片地址.ico&quot;&gt;（各种图标可以到icon网上找） 三、格式排版标签 &lt;br/&gt;换行 &lt;hr/&gt;分隔线 &lt;p&gt;段落 &lt;pre&gt;原样输出（按照原格式输出） &lt;h1&gt;&lt;/h1&gt;标题标签 &lt;center&gt;&lt;/center&gt;居中 HTML实体： * &amp;nbsp; 空格 * &amp;lt; &lt; * &amp;gt; &gt; * &amp;quot; “ 引号 * &amp;copy; © 版权 * &amp;yen; ¥ * &amp;times; × * &amp;divide; ÷ * &amp;reg; ® 四、列表标签 &lt;ol&gt; 定义有序列表 &lt;ul&gt; 定义无序列表excemple:&lt;h4&gt;无序列表:&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ul&gt; &lt;li&gt; 定义列表项excemple:&lt;h4&gt;大写字母列表：&lt;/h4&gt; &lt;ol type=&quot;A&quot;&gt; &lt;li&gt;Apples&lt;/li&gt; &lt;li&gt;Bananas&lt;/li&gt; &lt;li&gt;Lemons&lt;/li&gt; &lt;li&gt;Oranges&lt;/li&gt; &lt;/ol&gt; &lt;dl&gt; 定义定义列表 &lt;dt&gt; 自定义列表项目 &lt;dd&gt; 定义自定列表项的描述–&gt; 五、文本标签 em强调 表现为斜体 strong 强调 表现为加粗 blockquote引用 六、链接和锚点 URL同一资源定位符,万维网的每一个文件都有一个URL a标签属性： href的值是URL、target新网页从哪个窗口打开（_self/_blank）、title 提示、download下载（H5新增） 锚点&lt;a name=&quot;锚点的名字&quot;&gt;&lt;/a&gt;、使用超链接#跳到指定位置 七、图像 img标签的属性：srcalt图片无法显示时显示文字titlewidth/height usemapusemap用于图片的映射。一个图像被分成几个区域，当用户点击某一个区域时，将被链接到不同的文档中。 &lt;a name=&quot;page1&quot;&gt;&lt;a/&gt; &lt;img src=&quot;&quot; usemap=&quot;mymap&quot;&gt; &lt;map name=&quot;mymap&quot; id=&quot;mymap&quot;&gt; &lt;area shape=&quot;rect&quot; coords=&quot;0,10,20,20&quot; href=&quot;#page1&quot;&gt; 八、表格 table标签 属性：border、width/height、cellspacing(单元格之间的间隙，默认2)、cellpadding(单元格与单元格内容之间的间隙，默认0)、align、bgcolor、background tr标签 属性：align(行内文字的水平对齐方式left/center/right)valign(行内文字的垂直对齐方式top/middle/bottom)height行高度bgcolor背景颜色 td标签属性：align、valign、width、height th标签 表头 九、表单 form属性有action、method、target、enctype 1&lt;form action=&quot;http://www.baidu.com/s&quot; method=&quot;get&quot;&gt; inputnametype(text默认文本框、password密码框、radio单选框、checkbox复选框、file文件上传、submit提交按钮、reset重置按钮、button普通按钮)value type值不同value的意义不同size 控制输入框宽度 适用于text/passwordmaxlength 最大输入字符个数 适用于text/passwordchecked 默认选中 适用于radio/checkboxreadonly 只读disabled 表示不可用示例： 1&lt;input type=&quot;text&quot; name=&quot;wd&quot; placeholder=&quot;请输入您的用户&quot; size=&quot;50&quot; maxlength=&quot;5&quot; disabled&gt; buttontype属性 submit（默认）、reset、button select属性 name、size option属性 value、diabled、selected（默认选项） 123456&lt;select name=&quot;xueli&quot;&gt;&lt;option value=&quot;boshi&quot;&gt;博士&lt;/option&gt;&lt;option value=&quot;shuoshi&quot;&gt;硕士&lt;/option&gt;&lt;option value=&quot;ben&quot;&gt;本科&lt;/option&gt;&lt;option value=&quot;zhuan&quot;&gt;专科&lt;/option&gt;&lt;/select&gt; textarea属性 rows(高度)、cols(宽度) 123456&lt;tr&gt;&lt;td&gt;自我介绍&lt;/td&gt;&lt;td&gt;&lt;textarea name=&quot;text&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;&lt;/td&gt;&lt;/tr&gt; label 12345&lt;tr&gt;&lt;td&gt;&lt;label for=&quot;pwd&quot; &gt;密码&lt;/label&gt;&lt;/td&gt;&lt;!-- 点击密码光标移动到后面的文本框 --&gt;&lt;td&gt;&lt;input type=&quot;password&quot; id=&quot;pwd&quot; name=&quot;pwd&quot;&gt;&lt;/td&gt;&lt;/tr&gt;]]></content>
      <categories>
        <category>web开发</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>web基础</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javaweb入门笔记-5-JSP技术]]></title>
    <url>%2F2018%2F03%2F31%2FJavaweb%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-5-JSP%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[JSP：一种动态web资源的开发技术基本介绍：1.JSP全名为Java Server Pages中文名叫java服务器页面 后缀名为(*.jsp)2.用JSP开发的Web应用是跨平台的，既能在Linux下运行，也能在其他操作系统上运行。3.它实现了Html语法中的java扩张（以 &lt;%, %&gt;形式）。JSP与Servlet一样，是在服务器端执行的。通常返回给客户端的就是一个HTML文本，因此客户端只要有浏览器就能浏览。 JSP的四种数据保存范围在 Jsp 开发中，可以保存数据，Jsp 提供了四种数据保存范围；分别是: Page 范围： 只在一个页面中保存数据； javax.servlet.jsp.PageContext(抽象类) Request 范围： 只在一个请求中保存数据； javax.servlet.http.HttpServletRequest(接口)(在同一个服务器内转发时。转发两个界面前后都可以访问到数据） Session 范围： 在一次会话范围中保存数据，仅供单个用户使用；javax.servlet.http.HttpSession(接口)(浏览器关闭的话就不可以访问数据了) Application 范围： 在整个服务器上保存数据，所有用户共享；javax.servlet.ServletContext(接口) JSP语法 JSP模板元素:JSP页面中的HTML内容。定义了网页的基本骨架，即结构和外观。 JSP表达式:用于将程序数据输出到客户端。如，&lt;%=变量或表达式 %&gt;脚本表达式(无分号)，用于输出数据。 JSP脚本片段:用于在JSP页面中编写多行java代码,严格遵循java语法。一个JSP页面可有多个脚本片段，它们可以相互访问(和放在一对&lt;% %&gt;中一样),单个片段可不完整。通过scriptlet标签我们可以在JSP里嵌入Java代码 第一种&lt;%! %&gt;：我们可以在里面定义全局变量，方法以及类 第二种：&lt;% %&gt; 我们可以在里面定义局部变量，编写语句 第三种：&lt;%= %&gt; 我们可以在里面输出一个变量或则一个具体内容 和JSP语言里的out对象基本一样 譬如&lt;%= b%&gt; JSP声明:JSP中代码默认翻译到servlet的service方法中，而JSP声明中的代码被翻译到_jspService方法外。语法：&lt;%! java代码 %&gt;。 JSP注释:格式&lt;%-- 注释 --%&gt;，注释的内容不会发给浏览器。 客户端不可见 JSP指令:是为JSP引擎设计的，定义了三个指令:page指令，include指令，taglib指令。语法:&lt;%@ 指令 属性名=&quot;值&quot; %&gt;。 page指令:定义各种属性，作用于整个JSP页面。 include指令:用于包含JSP文件(页头、页脚)。属于静态包含(编译时包含)，它包含的所有JSP会编译成一个servlet。 taglib指令:用于在JSP页面导入标签库。 JSP标签:也称为jsp Action元素，用于在jsp页面中提供业务逻辑功能，避免在jsp页面中直接写java代码而难以维护 JSP内置对象:（也是九大隐式对象）request,response,session,application,config,page,exception,out,pageContext 常用JSP指令JSP包含指令 静态包含（先包含再编译处理）&lt;%@include file=”要包含的文件”%&gt; 动态包含（先编译处理后包含）&lt;jsp:include page=”要包含的文件”%&gt;在日常开发过程中，以后用动态包含 JSP跳转指令123&lt;jsp:forward&gt; &lt;jsp:param value=”” name=””&gt;//可以将带过去的两个参数通过request对象传送给下一个界面&lt;/jsp:forward&gt; 注意：服务器内部跳转可带参数，跳转以后基本网址并没有发生改变。客户端跳转则不可以带参数 内置对象详解在 Jsp 开发中，Jsp 提供了 9 个内置对象，这些内置对象将由容器为用户进行实例化，用户直接使用即可。这9 个内置对象分别是：request,response,session,application,config,page,exception,out,pageContext 常用的是前面 5个，需要熟练掌握； pageContext对象有两个常用函数: pageContext.setAttribute(“name”,”hyoyew”); pageContext.getAttribute(“name” );pageContext 内置对象是一个比较特殊的对象。它相当于页面中所有对象功能的集合，即使用它可以访问到本页面中所有对象。pageContext 内置对象由Jsp 容器创建并初始化，pageContext 对象提供了对 JSP 页面所有对象及控件的访问12345678910111213//访问到本页面中所有对象 &lt;% pageContext.setAttribute(&quot;name0&quot;, &quot;pageInfo&quot;); request.setAttribute(&quot;name1&quot;, &quot;requestInfo&quot;); session.setAttribute(&quot;name2&quot;, &quot;sessionInfo&quot;); application.setAttribute(&quot;name3&quot;, &quot;applicationInfo&quot;); out.println(&quot;使用pageContext&lt;br/&gt;&quot;); out.println(&quot;page中的属性值：&quot;+pageContext.getAttribute(&quot;name0&quot;)+&quot;&lt;br/&gt;&quot;); out.println(&quot;request中的属性值：&quot;+pageContext.getRequest().getAttribute(&quot;name1&quot;)+&quot;&lt;br/&gt;&quot;); out.println(&quot;session中的属性值：&quot;+pageContext.getSession().getAttribute(&quot;name2&quot;)+&quot;&lt;br/&gt;&quot;); out.println(&quot;application中的属性值：&quot;+pageContext.getServletContext().getAttribute(&quot;name3&quot;)+&quot;&lt;br/&gt;&quot;); %&gt; response对象response 内置对象和 request 内置对象是相对应的。就像一次电话包括拨打的人和响应的人response 内置对象用于响应客户端请求，向客户端输出信息；javax.servlet.HttpServletResponse 接口它的应用： 自动刷新应用（但是开发过程中一般使用JS实现刷新页面） 12345678910111213141516171819&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt; &lt;%@ page import=&quot;java.util.*&quot;%&gt; //引入的包 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% // 每隔一秒刷新一次页面 response.setHeader(&quot;refresh&quot;,&quot;1&quot;); //refresh函数是底层提供的函数 // 获取当前时间 Date myDate=new Date(); //Date不是内置对象，需要导入包 %&gt; 当前时间：&lt;%= myDate.toLocaleString() %&gt; &lt;/body&gt; &lt;/html&gt; 页面重定向应用，实现客户端跳转注意和服务端跳转是有区别的,服务端跳转时是可以带数据的，这里只能读取session和location的值，不能带数据 12345678910111213141516&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt; &lt;%@ page import=&quot;java.util.*&quot;%&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% // 重定向，客户端跳转 response.sendRedirect(&quot;index.html&quot;); %&gt; &lt;/body&gt; &lt;/html&gt; 操作 cookie 应用这里的Cookie是本地的一个对象，是客户端的，就是在浏览器里可以找得到的cookie 和 session 的比较 cookie 信息是存客户端的， session 信息是存服务器的 Out 内置对象out 内置对象的方法是向客户端输出数据和管理缓冲区；底层 javax.servlet.jsp.JspWriter抽象类12345678910111213141516171819202122//向客户端输出各种类型的数据 &lt;/head&gt; &lt;body&gt; &lt;% out.println(&quot;&lt;h1&gt;&quot;); out.println(&quot;Hello Jsp Servlet&quot;); out.println(&quot;&lt;/h1&gt;&quot;); %&gt; &lt;/body&gt; &lt;/html&gt; //管理应用服务器上的输出缓冲区。 &lt;body&gt; &lt;% int totalbuffer=out.getBufferSize(); // 获取总共缓冲区的大小 int available=out.getRemaining(); // 获取未使用的缓冲区的大小 int user=totalbuffer-available; // 获取使用的缓冲区大小 out.println(&quot;总共缓冲区的大小：&quot;+totalbuffer); out.println(&quot;未使用的缓冲区的大小：&quot;+available); out.println(&quot;使用的缓冲区大小：&quot;+user); %&gt; &lt;/body&gt; Config 内置对象Config 内置对象是 JSP 页面通过 JSP 容器进行初始化时被传递的对象。javax.servlet.ServletConfig 。在 Servlet初始化的时候，JPS 引擎通过 config 向它传递信息。这种信息可以是属性名和属性值匹配的参数，也可以是通过ServletContext对象传递的服务器的有关信息； exception 对象Exception 内置对象用来处理 JSP 文件在执行时发生的所有异常，它是 java.lang.Throwable 类的一个对象 jsp与JavaBeanJavaBean是一个遵循特定写法的java类，JavaBean常用于封装数据，具有如下特点： 该java类必须有一个无参的构造函数 属性必须私有化 私有化的属性必须通过public类型的方法暴露给其他程序，并且方法的命名也必须遵循一定的命名规范。 JSP中提供了三个关于JavaBean的标签： &lt;jsp:useBean&gt;:用于在JSP页面中查找或实例化一个JavaBean组件 &lt;jsp:setProperty用于在JSP页面中设置一个JavaBean组件的属性 &lt;jsp:getProperty&gt;:用于在JSP页面中获取一个JavaBean组件的属性 一些细节 &lt;jsp:useBean&gt;标签的标签体只在实例化bean时才执行 &lt;jsp:setProperty&gt;可用请求参数给bean属性赋值，支持8种基本数据类型的转换(把客户机提交的字符串转成相应的8种基本类型赋到bean的属性上) 在标签中将property=&quot;*&quot;，用所有请求参数为bean赋值，请求参数名称和bean属性名称必须要一致 如果JavaBean实例对象的某个属性值为null,那么使用&lt;jsp:getProperty&gt;标签输出结果为“null”字符串 拾遗在JSP文件中引入用到的Java包格式： &lt;%@ page import=&quot;java.util.*&quot; %&gt;]]></content>
      <categories>
        <category>web开发</category>
        <category>JSP</category>
      </categories>
      <tags>
        <tag>web基础</tag>
        <tag>JSP技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javaweb入门笔记-6-cookie和session]]></title>
    <url>%2F2018%2F03%2F31%2FJavaweb%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-6-cookie%E5%92%8Csession%2F</url>
    <content type="text"><![CDATA[Cookie是客户端技术；Session是服务器端技术。这里重点讲一下session。 API:javax.servlet.http:Class Cookiejavax.servlet.http:Interface HttpSession session对象概要介绍web服务器会给每一个用户自动创建一个session对象，为每一个session对象分配一个唯一表识的String类型的ID，这个ID用来区分其他用户。这样每个用户都对应一个session对象，不同用户的session对象互相不同。 当在不同文件夹里放不同的jsp文件并分别运行时：一个用户在同一个web服务目录中只有一个session对象 当用户访问相同的web服务目录的其他页面时，web服务器不会在重新分配session对象，直到用户关闭浏览器或这个session对象达到了它的生存期限。 当用户重新打开浏览器再次访问该web目录时，web服务器为该用户在创建一个新的session对象。需要注意的是：同一个用户在多个不同的web服务目录中对应的session对象时不同的，一个服务目录对应一个session对象 生命周期session对象由服务器创建 创建：调用request对象的getSession方法后才会创建session对象; getSession(false)`只获取， 不创建 销毁：默认30分钟没人使用则自动销毁。失效时间可在web.xml的&lt;session-config&gt;标签中使用&lt;session-timeout&gt;，单位分钟；也可调用session对象的invalidate方法销毁 session对象的应用： 用户登录 防止表单重复提交(暂时还不了解) 一次性验证码的校验(暂时还不了解) 使用session的案例:模拟在线考试系统1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;session1&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;sessionTest2.jsp&quot; method=&quot;post&quot;&gt; 考号： &lt;input type=&quot;text&quot; name=&quot;id&quot;/&gt; &lt;p&gt; 一、单项选择题（每题2分） &lt;br/&gt;&lt;br/&gt; 1.下列哪个方法是获取session中关键字是key的对象（ ）。 &lt;br /&gt; &lt;input type=&quot;radio&quot; name=&quot;one&quot; value=&quot;A&quot;/&gt; A．public void setAttribute(String key, Object obj)&lt;br/&gt; &lt;input type=&quot;radio&quot; name=&quot;one&quot; value=&quot;B&quot;/&gt; B．public void removeAttribute(String key)&lt;br/&gt; &lt;input type=&quot;radio&quot; name=&quot;one&quot; value=&quot;C&quot;/&gt; C．public Enumeration getAttributeNames()&lt;br/&gt; &lt;input type=&quot;radio&quot; name=&quot;one&quot; value=&quot;D&quot;/&gt; D．public Object getAttibute(String key)&lt;br/&gt; &lt;/p&gt; &lt;p&gt; 二、判断题（每题2分） &lt;br/&gt;&lt;br/&gt; 1.同一客户在多个Web服务目录中，所对应的session对象是互不相同的。 &lt;br/&gt; &lt;input type=&quot;radio&quot; name=&quot;two&quot; value=&quot;True&quot;/&gt; True &lt;input type=&quot;radio&quot; name=&quot;two&quot; value=&quot;False&quot;/&gt; False &lt;/p&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; name=submit&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot; name=reset&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;session2&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;sessionTest3.jsp&quot; method=&quot;post&quot;&gt; &lt;% //考号 String id = request.getParameter(&quot;id&quot;); //把考号id以“id”为关键字存储到session对象中 session.setAttribute(&quot;id&quot;, id); //单项选择第一题 String first = request.getParameter(&quot;one&quot;); //把答案first以“one”为关键字存储到session对象中 session.setAttribute(&quot;one&quot;, first); //判断第一题 String second = request.getParameter(&quot;two&quot;); //把答案second以“two”为关键字存储到session对象中 session.setAttribute(&quot;two&quot;, second); %&gt; 您的考号：&lt;%=id%&gt;&lt;br/&gt; 一、单项选择题（每题2分） &lt;br/&gt; 1.&lt;%=first%&gt; &lt;br /&gt; 二、判断题（每题2分） &lt;br /&gt; 1.&lt;%=second%&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;确认完毕&quot;/&gt; &lt;a href=&quot;sessionTest1.jsp&quot;&gt;重新答题&lt;/a&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;session3&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% //获取考号 //获取session中关键字是id的对象（考号） String id = (String) session.getAttribute(&quot;id&quot;); //计算成绩 int sum = 0; //如果单项选择第一题选中D选项，得2分。 //获取session中关键字是one的对象（选择答案） String first = (String) session.getAttribute(&quot;one&quot;); if (&quot;D&quot;.equals(first)) &#123; sum += 2; &#125; //如果判断第一题选中True，得2分。 //获取session中关键字是two的对象（判断答案） String second = (String) session.getAttribute(&quot;two&quot;); if (&quot;True&quot;.equals(second)) &#123; sum += 2; &#125; %&gt; 您的成绩公布如下： &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th width=&quot;50%&quot;&gt; 考号 &lt;/th&gt; &lt;th width=&quot;50%&quot;&gt; 成绩 &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;%=id%&gt;&lt;/td&gt; &lt;td align=&quot;right&quot;&gt;&lt;%=sum%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 关于cookie一些细节： 一个cookie只能标识一种信息，至少含有标识该信息的名称和值 浏览器一般只允许存放300个cookie，每个站点最多存放20个，每个cookie大小限制为4KB 默认是会话级别cookie(存储于浏览器内存)，浏览器进程关闭则删除。有效期通过maxAge设置，存于硬盘，0表示删除 删除cookie时，path必须一致，否则不会删除]]></content>
      <categories>
        <category>web开发</category>
        <category>Session</category>
      </categories>
      <tags>
        <tag>web基础</tag>
        <tag>JSP技术中的session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javaweb入门笔记-4-request和response]]></title>
    <url>%2F2018%2F03%2F31%2FJavaweb%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-4-request%E5%92%8Cresponse%2F</url>
    <content type="text"><![CDATA[request和response是什么?request是请求,在浏览器输入地址,回车,就是一个请求response是响应,服务器根据请求,返回数据到浏览器显示,就是一个响应 API: Interface HttpServletResponseInterface HttpServletRequest response设置响应体实现输出数据使用字节流向页面输出 程序以什么码表输出，就一定要控制浏览器以什么码表打开。 设置浏览器的编码让浏览器的编码和字节数组的编码一致 可有如下两种写法： 123response.setHeader(&quot;Content-type&quot;,&quot;text/html;charset=UTF-8&quot;)response.setContentType(&quot;text/html;charset=UTF-8&quot;)//默认调用setHeader和setCharacterEncoding//把分号`;`错写成逗号`,`，浏览器会提示下载 设置字节数组的编码用html技术的&lt;meta&gt;标签可以模拟一个http响应头，&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt;response可用setCharacterEncoding方法设置码表。字符流输出：PrintWritet-&gt;response-&gt;浏览器,response-&gt;浏览器默认使用iso-8859编码 文件下载使用ServerContext的getRealPath方法,再InputStream和OutputStream如果下载文件是中文名为中文，则文件名需要经过url编码URLEncoder.encode 文件下载的基本实现的步骤（0）设置头信息 Content-Disposition，无论是什么格式的文件都以下载方式打开（1）在服务器上面有一个可以下载的文件（2）从服务器上拿到这个文件（使用文件输入流得到文件）（3）使用输出流把文件写到浏览器1234567891011121314151617public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException &#123;//输入关联下载的资源String path = &quot;/download/a.zip&quot;;InputStream is = getServletContext().getResourceAsStream(path);int lastIndexOf = path.lastIndexOf(&quot;/&quot;);String filename = path.substring(lastIndexOf+1);response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;+filename);OutputStream os = response.getOutputStream();int len = 0;byte[] b = new byte[8192];while ((len=is.read(b))!=-1) &#123;os.write(b, 0, len);&#125;is.close();os.close();&#125; 随机图片使用BufferedImage在内存生成图片，再使用ImageIO输出。画图使用Graphics,旋转使用Graphics2D汉字的区间：\u4e00-\u9fa5 刷新和缓存刷新：一般不在servlet里加refresh头，而是在jsp加入&lt;meta&gt;头模拟。缓存：加入expires头,当前时间+要缓存的时长 请求重定向重定向 设置状态码和location头即可，或者直接使用response的sendRedirect方法。 向服务器两次请求。 浏览器会改变地址栏，一般适用于登录、购物等场景。 转发 调用ServletContex对象的getRequestDispatcher方法，再调用forward方法。 向服务器一次请求，浏览器地址栏不变。 一些细节： getOutputStream和getWriter方法跟别用于输出二进制数据、输出文本数据的ServletOutputStream、Printwriter对象，这两个方法相互排斥，只能调用其中一个，否则抛IllegalStateException异常。 response的输出流会自己关闭。Servlet的service方法结束后，Servlet引擎会检查并调用close方法关闭该输出流对象。 Request获取请求的基本信息 URI:标识某个资源 URL:标识互联网上某个资源 获取请求的url和uriString url = request.getRequestURL().toString(); System.out.println(url); String uri = request.getRequestURI().toString(); System.out.println(uri); 获取url后面的请求参数部分的字符串String params = request.getQueryString(); System.out.println(params); 获取请求方式String method = request.getMethod(); System.out.println(method); 获取主机名,IP地址String addr = request.getRemoteHost() + request.getRemotePort() + request.getRemoteAddr() + &quot;==user=&quot; + request.getRemoteUser(); System.out.println(&quot;addr: &quot; + addr); 获取 ContexpathString contextPath = request.getContextPath(); response.sendRedirect(contextPath + &quot;/index.jsp&quot;); 中文乱码url后面如果有中文数据，需要编码后再提交表单提交的数据使用的码表和该页面的码表一致，而getParameter方法默认使用ISO-8859码表。 解决： 对于post提交的数据，在获取数据前要使用request对象的setCharacterEncoding设置码表。 对于get提交的数据，只能手工解决。先对数据调用getBytes(&quot;ISO-8859-1&quot;)获取二进制字节，再用特定码表构建字符串。 超链提交的中文，解决办法同get提交的数据。也可以通过改服务器配置来解决乱码问题，但一般不建议使用。 URIEncoding:改tomcat的配置文件conf/server.xml的连接器&lt;Connector&gt;中的URIEncoding属性 useBodyEncodingForURI:将conf/server.xml的连接器&lt;Connector&gt;中的useBodyEncodingForURI置为true 请求转发应用场景：MVC设计模式 model : javabean; view : jsp; controller : servlet使用request域对象把数据带给转发资源。调用request对象的getRequestDispatcher方法，再调用forward方法。一次请求，浏览器地址栏不变。 forward一些细节 不能在关闭输出流后再调用转发，也不能调用两次，否则会抛出异常。 跳转之前会清空response中的数据。即数据只是写入到缓冲区而没真正输出到客户端，则可调用forward方法，原来写入到缓冲区的内容被清空，但响应头字段信息保持。include方法可以用于包含一些公共页面(一般不在servlet中包含) 地址的写法以斜杠/开头。如果是给服务器用，则/代表当前web应用；如果给浏览器用，则/代表网站。 拾遗1 使用字节流向页面输出解决方法： 设置浏览器的编码 设置字节数组的编码让浏览器的编码和字节数组的编码一致 123// &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;response.setHeader(&quot;content-type&quot;, &quot;text/html; charset=UTF-8&quot;);response.getOutputStream().write(&quot;4.1 使用字节流向页面输出内容&quot;.getBytes(&quot;UTF-8&quot;)); 2 使用字符流向页面输出解决方法： 设置response缓冲区的编码 设置浏览器的编码response缓冲区的编码和浏览器的编码一致 1234response.setCharacterEncoding(&quot;UTF-8&quot;);// &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;response.setHeader(&quot;content-type&quot;, &quot;text/html; charset=UTF-8&quot;);response.getWriter().write(&quot;4.2 使用字符流向页面输出内容&quot;); 3 字符流向页面输出中文乱码问题解决，简写方式123// &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;reesponse.setContentType(&quot;text/html; charset=UTF-8&quot;);response.getWriter().write(&quot;4.2 ,简写 ,使用字符流向页面输出内容&quot;); 链接request和response总结 - CSDN博客 有价值的内容包括：验证码的案例设置定时跳转]]></content>
      <categories>
        <category>web开发</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>web基础</tag>
        <tag>Servlet的request和response</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javaweb入门笔记-3-Servlet]]></title>
    <url>%2F2018%2F03%2F31%2FJavaweb%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-3-Servlet%2F</url>
    <content type="text"><![CDATA[这一篇介绍servlet入门API文档 Servlet API Document servlet简介servlet 是运行在 Web 服务器中的小型 Java 程序。servlet 通常通过 HTTP（超文本传输协议）接收和响应来自 Web 客户端的请求。要实现此接口，可以编写一个扩展 javax.servlet.GenericServlet 的一般 servlet，或者编写一个扩展 javax.servlet.http.HttpServlet 的 HTTP servlet。此接口定义了初始化 servlet 的方法、为请求提供服务的方法和从服务器移除 servlet 的方法。这些方法称为生命周期方法，它们是按以下顺序调用的： 构造 servlet，然后使用 init 方法将其初始化。 处理来自客户端的对 service 方法的所有调用。 从服务中取出 servlet，然后使用 destroy 方法销毁它，最后进行垃圾回收并终止它。 Servlet功能：1、接受浏览器发送过来的消息。2、给浏览器返回消息。浏览器认识html。可以动态去输出html Servlet的生命周期生命周期相关方法(life-cycle methods)Servlet的生命周期通过java.servlet.Servlet接口中的init()、service()、和destroy()方法表示。Servlet的生命周期有四个阶段：加载并实例化、初始化、请求处理、销毁。 1.调用 init 方法 初始化Servlet2.调用 Servlet中的service方法 处理请求操作3.调用 destory方法 执行Servlet销毁的操作 init方法：当服务器创建一个serlvet的时候，会去调用init方法。当我们第一次去访问一个servlet的时候，会去创建这个servlet对象。并且只会创建一次。如果配置了load-on-startup 表示服务器启动的时候就创建servlet实例。 service方法：客户端每一次请求，tomcat都会去调用servcie方法。处理用户的请求。并且给其响应。每一次请求都会调用servcie方法。 destroy 方法：当服务器销毁一个servlet的时候，会调用里面的destory方法。当我们的web服务器，正常关闭的时候，会去调用destroy方法。否则不会调用destroy的方法。 servlet实现开发步骤： 编写一个java类，实现servlet接口 把开发好的java类部署到web服务器 手动编写第一个servlet 实现servlet接口（javax.servlet.Servlet） 重写service方法(service方法每次请求都会调用一次),当浏览器输入地址，访问servlet的时候，servlet会执行servcie方法。 在WebContent/WEB-INF/web.xml中配置servlet的访问路径 :浏览器访问servlet的路径 把项目部署到tomcat中，去启动tomcat。在地址栏中输入信息，访问servlet Servlet实现跳转 第一种情况：服务器调转/转发rd.forward(request, response);protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setAttribute(&quot;requestKey&quot;, &quot;request值&quot;); HttpSession session=request.getSession(); // 获取session session.setAttribute(&quot;sessionKey&quot;, &quot;session值&quot;); ServletContext application=this.getServletContext(); // 获取application application.setAttribute(&quot;applicationKey&quot;, &quot;application值&quot;); RequestDispatcher rd=request.getRequestDispatcher(&quot;target.jsp&quot;); rd.forward(request, response); // 服务器调转/转发 } 第二种情况：客户端跳转/重定向response.sendRedirect(&quot;target.jsp&quot;); protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setAttribute(&quot;requestKey&quot;, &quot;request值&quot;); HttpSession session=request.getSession(); // 获取session session.setAttribute(&quot;sessionKey&quot;, &quot;session值&quot;); ServletContext application=this.getServletContext(); // 获取application application.setAttribute(&quot;applicationKey&quot;, &quot;application值&quot;); response.sendRedirect(&quot;target.jsp&quot;); // 客户端跳转/重定向 }]]></content>
      <categories>
        <category>web开发</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>web基础</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javaweb入门笔记-2-Http入门]]></title>
    <url>%2F2018%2F03%2F31%2FJavaweb%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2-Http%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[HTTP协议介绍 HTTP协议 HTTP（hypertext transport protocol），即超文本传输协议。这个协议详细规定了浏览器和万维网服务器之间互相通信的规则。 客户端与服务端通信时传输的内容我们称之为报文。 HTTP就是一个通信规则，这个规则规定了客户端发送给服务器的报文格式，也规定了服务器发送给客户端的报文格式。实际我们要学习的就是这两种报文。客户端发送给服务器的称为”请求报文“，服务器发送给客户端的称为”响应报文“。 请求的协议格式一个完整的HTTP请求包括：一个请求行、若干请求头、以及实体内容请求的HTTP协议格式：请求行请求头空行请求体 请求头字段 Accept:用于告诉服务器，客户机支持的数据类型 Accept-Charset:用于告诉服务器，客户机采用的编码 Accept-Encoding:用于告诉服务器，客户机支持数据压缩格式 Accept-Language:客户机的语言环境 Host:客户机通过这个头告诉服务器，想访问的主机名 If-Modified-Since:客户机通过这个头告诉服务器，资源的缓存时间 Refer:客户机通过这个头告诉服务器，它是从哪个资源访问服务器的(防盗链) User-Agent:客户机通过这个头告诉服务器，客户机的软件环境 Cookie:客户机通过这个头向服务器带数据 Connection:这个请求完了，是保持连接还是关闭 Range:断点下载 bytes=n1-n2,传输范围n1到n2字节 bytes=n-，传输web资源中第n个字节以后的所有内容 bytes=n,传输最后n个字节 响应的协议格式一个HTTP响应代表服务器向客户端回送的数据，包括：一个状态行、若干消息头、以及实体内容响应的HTTP协议格式:响应首行响应头信息空行响应体 常见的响应码响应码对浏览器来说很重要，它告诉浏览器响应的结果； 200：请求成功，浏览器会把响应体内容（通常是html）显示在浏览器中； 404：请求的资源没有找到，说明客户端错误的请求了不存在的资源； 500：请求资源找到了，但服务器内部出现了错误； 302：请求重定向，当响应码为302时，表示服务器要求浏览器重新再发一个请求，服务器会发送一个响应头Location，它指定了新请求的URL地址； 具体响应码可参考：HTTP 状态消息]]></content>
      <categories>
        <category>web开发</category>
        <category>http</category>
      </categories>
      <tags>
        <tag>web基础</tag>
        <tag>HTTP笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javaweb入门笔记-1-Tomcat]]></title>
    <url>%2F2018%2F03%2F31%2FJavaweb%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-1-Tomcat%2F</url>
    <content type="text"><![CDATA[Tomcat服务器是一个开源小型web服务器 ，完全免费，主要用于中小型web项目，只支持Servlet和JSP 等少量javaee规范（就是JavaWeb编程接口） tomcat下载地址安装与配置教程 JavaWeb概念Java web，是用java技术来解决相关web互联网领域的技术的总称。web包括：web服务器和web客户端两部分。java在最早web客户端的应用有java applet程序，不过这种技术在很久之前就已经被淘汰了。java在服务器端的应用非常丰富，比如Servlet，jsp和第三方框架等等。java技术对web领域的发展注入了强大的动力简单的说，就是使用java语言实现浏览器可以访问的程序内容。称之为Java Web。 javaweb开发是基于请求和响应的： 请求：浏览器（客户端）向服务器发送信息 响应：服务器向（客户端）浏览器回送信息请求和响应是成对出现的。 web资源分类所谓web资源即放在Internet网上供外界访问的文件或程序，又根据它们呈现的效果及原理不同，将它们划分为静态资源和动态资源。 静态web资源：固定不变数据文件（静态网页 HTML、CSS文件、文本、音频、视频） 静态web技术：HTML+CSS+JavaScript 动态web资源：一段服务程序，运行后，生成的数据文件 动态web技术：servlet，jsp，php， .net ,ruby、python等等 配置tomcat的端口tomcat默认的端口是8080（访问端口）http的默认端口是80，如果访问的时候输入http://www.baidu.com相当于http://www.baidu.com:80。当真正在项目上线之后，通常采用80，修改方法如下：1）找到tomcat目录/conf/server.xml2）修改port的值，将port端口的值修改为803）然后在浏览器中输入 http://127.0.0.1:80 或 http://127.0.0.1访问测试 常用的布署工程到Tomcat中的两种方式即把我们自己书写的html，servlet这些信息，部署到tomcat的方式。 第一种方法：在conf/server.xml文件的host元素中配置，例如：在host标签内书写如下内容12&lt;Context path=&quot;/atguigu&quot; docBase=&quot;D:\atguigu&quot;/&gt;&lt;Context path=”浏览器要访问的目录---虚拟目录” docBase=”网站所在磁盘目录”/&gt; 配置好之后，要重启服务器。缺点（Tomcat7.0之后）：如果配置错误：tomcat会启动失败。（如果tomcat里面存放的其他的网站），其他网站也会停机。 第二种方式：将网站目录复制到tomcat/webapps目录（常用，必须掌握）有一个网站（一个文件夹），把文件夹复制到tomcat的webapps目录下。文件夹的名字，就是网站或者工程的访问目录.相当于之前配置 &lt;Context path=””的配置]]></content>
      <categories>
        <category>web开发</category>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>web基础</tag>
        <tag>tomcat笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo搭建博客出现hexo -d报错如何解决]]></title>
    <url>%2F2018%2F03%2F31%2F%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%87%BA%E7%8E%B0hexo-d%E6%8A%A5%E9%94%99%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[如果在使用hexo d命令的前提下，直接修改.git下面的config文件是无法成功的。原因是：使用该命令之后，会根据_config.yml下面的deploy节点进行cofig文件的覆盖。也就是说，_config.yml如果不做修改，无论如何修改.git下面的配置文件都是无效的，都会被覆盖。能够在本地打开，但是部署不到github上去 hexo d的时候报错123456789101112131415161718192021222324252627$ hexo dINFO Deploying: gitINFO Clearing .deploy folder...INFO Copying files from public folder...warning: LF will be replaced by CRLF in 2015/12/05/hello-world/index.html.The file will have its original line endings in your working directory.……warning: LF will be replaced by CRLF in index.html.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in js/script.js.The file will have its original line endings in your working directory.On branch masternothing to commit, working directory cleanbash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for 'GitHub · Where software is built': No errorFATAL Something's wrong. Maybe you can find the solution here: TroubleshootingError: bash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for 'GitHub · Where software is built': No errorat ChildProcess.&lt;anonymous&gt; (E:\SwuComputer\HTML5\hexo\node_modules\hexo-deployer-git\node_modules\hexo-util\lib\spawn.js:42:17)at emitTwo (events.js:87:13)at ChildProcess.emit (events.js:172:7)at maybeClose (internal/child_process.js:818:16)at Process.ChildProcess._handle.onexit (internal/child_process.js:211:5) 详细答案：有关使用 Hexo 和 GitHub 搭建博客，出现 hexo -d 报错如何解决？ - https://www.zhihu.com/question/38219432 我试了了高票答案，但是发现不行，最后用下面这个解决了。 解决方法修改配置文件：根目录下的_config.yml，修改deploy节点。 原来的配置为：1234deploy: type: git repo: https://github.com/&#123;yourname&#125;/&#123;yourname&#125;.github.io.git branch: master 修改为如下： deploy: type: git repo: https://{yourname}:{yourpassword}@github.com/{yourname}/{yourname}.github.io.git branch: master 亲测可行!!!]]></content>
      <categories>
        <category>hexo</category>
        <category>解决部署问题</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>搭建博客时部署报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet中doGet与doPost的区别]]></title>
    <url>%2F2018%2F03%2F31%2FServlet%E4%B8%ADdoGet%E4%B8%8EdoPost%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[doGet和doPost其实就是用来接收前端传过来的数据，本质上都是请求方法。 通过JSP页面访问Servlet首先我们要知道什么时候用到doGet和doPost：Answer:当通过JSP页面访问Servlet时 我们可以通过JSP页面的表单或者超链接请求某个servlet。通过JSP页面访问servlet的好处是JSP页面负责页面的静态信息处理，动态信息处理有Servlet完成。 通过表单访问servlet 12345&lt;form action 访问=&quot;islogin&quot; method=&quot;post&quot;&gt;....&lt;/form&gt; 通过超链接访问Servlet在JSP页面中，可以单击超链接访问Servlet对象，同时可以通过链接向Servlet提交信息。示例： 1&lt;a herf =&quot;loginSerlet? user=ty&amp;pwd=zg&quot;&gt;查看用户名和密码&lt;/a&gt; “查看用户名和密码”这个超链接就将user和pwd的两个信息提交给Servlet处理。 工作原理当服务器创建servlet对象后，servlet对象调用init方法初始化自己。当服务器收到一个Servlet请求时，就会产生一个新进程，在这个线程中，让Servlet对象调用service（）方法为请求做出响应。service方法首先检查HTTP请求类型（get或post），并根据用户的请求方式，在service（）方法中对应的调用doGet()或doPost()方法。 优点：在Servlet类中重写doGet()或doPost()方法来响应用户的请求，可以增加响应的灵活度，同时减轻服务器的负担。 一般情况下无论用户请求是post或get,服务器的处理过程完全相同。我们也可以在doPost()中写处理过程的代码，而在doGet()方法内再调用doPost方法。 Get和Post的区别： get是从服务器上获取数据，post是向服务器传送数据。 在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。 对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。 GET方式提交的数据最多只能有1024字节，而POST则没有此限制。 安全性问题。正如在1中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好。]]></content>
      <categories>
        <category>web开发</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>web基础</tag>
        <tag>doGet和doPost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习方法论]]></title>
    <url>%2F2018%2F03%2F22%2F%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[每个人都有自己做事的方法论，在网上看到一篇短小的关于编程的交流总结，关于如何在做事时提高效率·做好预研，收集相关前人成果，避免无满的重复劳动·在可行性判新阶段，能找到工具就不写代码，能用脚本语言写就不要用编译语言，把完美主义放在最终实现阶段·做好笔记并定期整理，速忘会让所有的投入都白白浪费·多交流，别人说一个工具的名字可能让你节约敷小时·咖啡可以提高思维效率，而且合法·无论怎么提高效率，要成为专家，都需要大量的时间投入]]></content>
      <categories>
        <category>随笔</category>
        <category>学习方法论</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>方法论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS操作DOM对象和常用全局函数总结]]></title>
    <url>%2F2018%2F03%2F19%2FJS%E6%93%8D%E4%BD%9CDOM%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B8%B8%E7%94%A8%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[DOM：Document Object Modeldocument对象是DOM核心对象作用：对html中的内容、属性、样式进行操作节点树中节点之间的关系：父子、兄弟 JS操作DOM对象访问DOM中的元素很多时候需要访问DOM中的元素，主要通过getElementById(),getElementsByTagName(),getElementsByClassName()方法获取 给DOM中元素添加属性在DOM元素中插入内容1234&#123; &lt;div id=&quot;context&quot;&gt;Hello,2017&lt;/div&gt; document.getElementById(&quot;context&quot;).innerHTML=&quot;节日快乐&quot;; &#125; 譬如：js定义函数，DOM对象的onclick=”函数名”来执行函数 修改Dom节点可以修改节点的样式。获得style对象，然后更改对象的某项值即可 添加DOM对象两种方法:前加，追加步骤大致是：定义新节点 var定义即可，用document的create TextNode()函数即可。然后：1.Insert Before()前加元素有两个参数，前面的是已经存在的DOM对象，后面的是要添加的对象2.appendChild()在dom中追加元素 删除Dom对象先get父亲节点以及子节点然后用remove函数，就可以了 JavaScript对象对象的定义用var来直接定义 { var p=new object(); p.name=&quot; jack&quot;;//(动态语言才可以，java不可以) alert( p. name);//直接输出成功 } 动态的添加属性和方法添加属性时也比较方便直接 p.func= speak; p.func(“ hello hello 大家好)”); 动态的删除属性和方法用delete删除 delete p. name; delete p.func; JS中对象的构造方法基于原型的构造方法 function person( name, age) { this. name= name; this. age=age; this. func=speak();//函数也可以直接构造 } js全局函数常用全局函数（全局函数不属于任何一个自己定义的对象） Eval() 执行函数专门用来执行代码的动态的执行代码1、将字符串解析为可执行的JavaScript语句2、可以将字符串（符合对象格式的）转化为对象类型 escape(): 对字符串进行编码该函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。 注意：该函数不能用于编码 URIs(通用资源标识符（UniformResourceIdentifier,简称”URI”）） unescape()*: 解码由escape()编码的字符串 encodeURI :对字符进行编码decodeURI :对字符进行解码isNaN(): 判断当前是否是数字，返回值true false,是数字返回false,不是数字返回true;parseInt() 类型转换Number(object):把对象的值转换为数字 如果对象的值无法转换为数字，Number()函数返回NaN。 如果参数的Date对象，Number()返回从1970年1月1日到现在所经历的毫秒数String():把对象的值转换为字符串String() 函数返回与字符串对象的toString()方法值一样 JavaScript. window的几个常用方法alert() 全局方法，可以弹出一个警告框。然而实际上，它是window对象的一部分。也就是说，完整的写法如下: window.alert(); parseInt(); 全局方法，可以将变量强转为整数完整的写法如下： window.parseInt();confirm() 确认函数用户交互、有boolean返回值；是一个阻塞式的方法，alert（）也是阻塞式方法promote()接收用户的反馈信息，返回值是字符串setinterval(int n)载入几次Window. onload()当文本全部加载完成后当页面加载完成的时候，触发该事件的发生，如果该事件绑定了函数，即执行该函数Window. onresize()当窗口大小发生改变后settime(，)多长时间刷新一次settime()第一个参数是函数名，第二个是时间，单位是毫秒，500毫秒为5秒 定时器 setTimeout setTimeout(function(){ alert(); },1000); //表示该函数延迟1000毫秒执行 More info——-&gt;: 请移步我的CSDN博客：hyo555，谢谢！！！]]></content>
      <categories>
        <category>web开发</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>JavaScript基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+next主题搭建博客]]></title>
    <url>%2F2018%2F02%2F02%2FHexo-next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[寒假前无意间看到高年级的学长自己做的博客网站，很精美！动心了之后决定自己做一个“高仿版” 。以上是效果图 古人云：工欲成其事必先利其器。在互联网高度发达的今天，知识很容易被检索到，在纷繁世界中进行知识的筛选已经成了做事情前一项非常必要的预备工作。 下面的这些链接是我在搭建过程中筛选过的文章，希望它能帮助你节省去筛选有用干货的时间帮助你搭建自己的个人精美博客。官方文档首先是最权威的： 文档 | Hexo https://hexo.io/zh-cn/docs/index.html内容包括：什么是 Hexo？安装安装前提安装 Git安装 Node.js安装 Hexo 开始使用 - NexT 使用文档 http://theme-next.iissnan.com/getting-started.html内容包括：安装 NexT主题设定集成第三方服务友情提示：在你对next主题进行个性化设置之前请务必把官方文档看一遍，因为它已经比较全面，可以帮助你解决一半的问题。 网上的实用链接给予的个性化帮助更多：1.自己动手搭建个人博客到优化 - CSDN博客 http://blog.csdn.net/nijun914/article/details/758088392.Hexo的Next主题配置 - syd192 - 博客园 http://www.cnblogs.com/syd192/p/6074323.html3.hexo的next主题个性化教程：打造炫酷网站 - 距离的博客 - CSDN博客 http://blog.csdn.net/qq_33699981/article/details/727169514.Hexo博客之主题美化 - 简书 https://www.jianshu.com/p/70dbff8d76085.hexo高阶教程：next主题优化之加入网易云音乐、网易云跟帖、炫酷动态背景、自定义样式，打造… - 简书 https://www.jianshu.com/p/76ce3729746d6.Hexo中播放网易云音乐的实践 http://weqeo.com/2016/10/11/Hexo%E4%B8%AD%E6%92%AD%E6%94%BE%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%9A%84%E5%AE%9E%E8%B7%B5/ 其他有用的链接：判断想要设置的背景颜色具体名称：HEX color - HTML CSS Color http://www.htmlcsscolor.com/hex/F5F5F5在hexo上的编辑文章：Markdown语法说明 - 时光 • 印记 http://erikge.com/articles/markdownSyntax/小图标网站：Icons | Icons | Font Awesome https://fontawesome.com/icons?d=gallery]]></content>
      <categories>
        <category>hexo</category>
        <category>安装教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大江东去》读书笔记]]></title>
    <url>%2F2018%2F01%2F18%2F%E5%A4%A7%E6%B1%9F%E4%B8%9C%E5%8E%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这是一位大江东去的读者的几篇书评，帮助我们了解小说的时代背景。 《沧桑二十年》第一篇 我是60年代生人，大江这20年，也是我人生成长历程中重要的20年，大江中提到的重要事件几乎都亲身经历过，所以想对照自身经历过的人或事分析大江，大家可以一笑而过。ps：没查资料，以记忆为准，如有错误请见谅。一、人物分析宋：62年出生，原为□□子弟，78年考入大学，分配进大型国营企业，提升迅速。没经历过□□的mms不会了解黑5类出身的孩子在当时的地位。我们家的成份比较高，除了舅妈家是富农外，所有的亲人家成份都是地主。当时所有的表格都有家庭成分一栏，我永远要等别人都交完了，没人在的时候才磨磨蹭蹭交老师，生怕别人看见笑话。那真的是不光彩的事情。有时打架，知道的同学也会骂你一声狗崽子。小宋比我出生还早，□□经历的时间更长，受的屈辱自然更多。但小宋又很幸运，赶上了77年恢复高考。他虽然是78年才上大学，是第二届学生，但77、78因为仅仅间隔半年，被统称为□□后第一批大学生。（交代一下时间背景：77届学生是77年冬天高考，入学已经是78年春天了，就和小宋他们只差了半年）小宋这批学生非常幸运，毕业后赶上了中央提出的“知识化、年轻化、专业化”的机会，但凡能力好些的都发展不错，提升很快。（我接触最快的，毕业5年，市委常委）所以我们在耐宝的文中可以看到这2大经历对小宋的影响：1、屋檐底下做人的经历使得小宋谨言慎行，少年老成，同时又对政治非常敏感。2、充分认识学习机会来之不易，对学习机会非常珍惜，专业功底扎实。3、机会好、专业好、外语好、做人谨慎、善于分析形势，所以在同龄人中迅速脱颖而出，走上领导岗位。因为年轻有学历，比水书记、程厂长、闵厂长这类政治干部了解技术，又比刘工这种老派的技术人员掌握新技术和外语；和虞相比，幼年时狗崽子的经历使他为人踏实、工作认真，赢得上下的尊重；对政治的敏感使他善于审时度势，抓住机遇。小宋的机会就这样出现在眼前。这类人在当时大有人在，目前也多数位居高位。雷：按照耐宝的描述，雷78年时已经26岁复员了。所以他的人生轨迹注定是另一种风采。□□开始时，雷还是小学生，没真正参与□□。受□□影响不太重，再加上当过兵，所以他的思维方式没被□□所束缚，从军的经历又使他思维方式较直线化、少顾虑，对改革政策容易接受并实行，又有着小农的狡猾，这是他成为改革先锋的个人原因。社会背景则表现为当时中央对农村改革非常重视，或者可以说改革是从农村开始的，记得当时连续几年的一号文件都是关于农村的。雷的军旅生涯使他习惯一言堂，拳头说话，对下属、对村民，包括对县电缆厂都如此；小农的狡猾使他懂得小利换大利，对信用社主任、陈平原用贿赂和交换谋求自己的利益。雷的背后如果没有徐在政策上的指导和小宋在管理和技术方面的指点，以他的眼光和境界能成功，但走偏的可能性太大，如禹作敏。 杨：小杨按耐宝的说法，65年出生，天，离我太近了，但因为生活环境差距太大，反而最不熟悉的就是他。这里只能试着分析：小杨家境贫寒，寡母带大了几个孩子，他作为长子，小小年纪把家庭重担扛在肩上。他没有宋的学历，不可能走入国企；没有雷的年纪和经历，不可能成为乡镇企业的领导；他的条件逼着他只能走个体户的道路。他们在夹缝中生存，只能靠拉关系、走后门才能打进被国营和集体牢牢占据的市场。而改革之初，人们对个体户的人是停留在投机倒把的印象中，而且当年许多个体户是劳改释放犯因找不到工作才做的，大家对他们并不信任。再加上个体的产品虽然便宜但质量不过关，数次被人们赶出市场，如焚烧温州鞋和大江里的老王事件。小杨初期走街串巷的游贩生涯，给他的为人深深刻下烙印：油嘴滑舌、看人下菜碟、计较蝇头小利。这些特点做小生意可以，却成不了大事。好在老王事件及时给了他一个教训，让他看到不足并努力改正，为成功奠定基础。小杨还遇到了当年个体户的普遍问题：红帽子。由于人们对个体户普遍缺乏信任，逼得许多人不得不挂靠在国营或集体的旗下，其后带来纠纷无数。因为没有明确财产权属关系，当时的政策又不保护私营经济，很多人的财产被上级单位拿走了。小杨幸运的是找到小雷家，应该不致如此。这是3个主要人物，其他代表性人物分析如下：徐：这是改革开放之初政策的最大收益者。父辈是老革命，他们生在新中国，长在红旗下，基础教育是在所谓的子弟学校（如北京4中、101中学等）中完成的，他们拥有高高在上的生活圈子。按78年任县长分析，他的父辈在□□中也应未受冲击，本人应该是工农兵学员，完成了高等教育。所以改革开放后，他们迅速占据了领导岗位，和老干部比年轻，和土干部比学历，这时又没有77、77届的威胁（等77、78毕业的时候，他们的羽翼早已丰满，威胁不到他们了），背靠大树，他们经商的发大财，从政的升迁迅速，是当时的红人。水：这是当年老干部的代表。他们在□□中被赶下台，78年恢复政策才重新掌权。因为失去过，所以更加珍惜。他们对权力狂热地追求，嗜权如命；又受传统政治影响，喜欢玩弄权术，享受那种万事掌握手中的感觉。当他们即将因年龄关系退出历史舞台时，他们是如此不甘心，千方百计留下自己的影响力，仍然企图控制一切。悲哀也正在于此。他们不愿相信时间的脚步推着时代前行，他们是必将被甩在身后的人。闵：尴尬的一代。他们上面受水的挤压，下面受宋的追赶。和水比不过权术，和宋比不过技术，注定是过渡性人物。刘：木纳的老知识分子代表。由于技术过硬，他们被提上领导岗位，也因为只懂技术不能进入权力核心，是被使用的角色。当以宋为代表的新一代知识分子追赶上来的时候，他们力不从心，只能退出历史舞台。虞：下海的第一批人。虽然是被水挤出金州，但下海仍是他主动的选择。当年敢下海的人，除了胆大以外，往往也确实有一定的能力。翻翻今天的财富榜，好多人都是第一批吃螃蟹的人，如希望集团的刘氏兄弟。何况虞现在又和外商挂钩，是新一代的买办。梁：改革开放后第一批留学生。他们掌握国外的先进知识，又具有中国背景，应是外方办事处的首代人选。耐宝还没写到这里，只好猜了。其他不具备时代代表性的人物就不写了。停笔至此，万分感慨。耐宝几乎将改革开放的代表人物写全了，丰满又具有鲜明的时代感，佩服佩服。 《沧桑二十年》第二篇还是查了资料才敢下笔，瞎说实在不好。1978年：耐宝的小说里，这只是属于序言的一年，但对整个中国而言，这一年是新中国历史上非常重要的转折之年。这一年发生了太多的事情，我挑和大江有关的事说：虽然76年粉碎“□□”，但毛的继任者华仍然踏着毛的脚步前进：“按既定方针办”，“凡是□□做出的决策，我们都坚决维护；凡是□□的指示，我们都始终不渝地遵循”。国家并没有从此走上康庄大道。这引起老干部的不满，社会也急需变革。1月，中组部提出为□□中打倒的老干部安置工作，很多老干部官复原职或重新安置，其中应包括水书记和宫书记。77年底恢复高考，78年3月，□□后第一批大学生入学了。小宋没赶上这一批，但幸运的赶上同年入学第二批。这标志着“白卷先生”时代的结束，社会开始重新重视知识。5月，□□提出“实践是检验真理的唯一标准”，拉开了真理标准大讨论，为改革做好理论和舆论准备。4月和10月分别提出□□摘帽和平反冤假错案（我伯父就是这时□□摘帽，从农村回到城市，补发工资过万元。在当时，这是笔天文数字），小宋家的帽子也快摘掉了。8-10月，中组部分三次召开选拨任用年轻干部的会议，小徐走马上任。12月伟大的十一届三中全会召开，新的时代开始了。 1979年这一年，小宋终于如愿以偿成为大学生。78、78届学生和我们差得并不多，所以等我们上学的时候，在老师眼里他们理所当然是我们学习的楷模。和我们这些校门对校门的学生不同，他们有着丰富的人生阅历，大多经历过□□的洗礼。而且这2届学生没有年龄限制，大的30多，有孩子了，小得像小宋这样不到20岁。这些人大多数被□□剥夺了接受高等教育的机会，当经过社会历练又重新回到校园的时候，他们的学习热情和理解能力都远远超过我们。他们是充满传奇的一代大学生。1月，中央做出为地富反坏摘帽的决定，小宋家快翻身了。2月，对越自卫反击战打响，全国人民的激情都被调动起来了。小宋因此结识了梁mm，雷东宝写了请战书，但谁也没想到这是一场速战速决的战争，1个月战争结束了。尽管时间短，这仍是场残酷的战争。我住的院子里有家人家亲戚的孩子阵亡了，据说骨灰盒里什么都没有。这一年，最重要的是社会重心的转移，经济第一次成为中心工作，改革的序幕真正拉开了。翻翻这一年的大事记，中央下发了无数文件，大多数都是关于经济和经济改革。中央全面推广安徽等省的农业生产责任制，联产承包，包产到户。和小雷家的情况不同，大部分农村是把所有的集体财产能够都分了，集体经济土崩瓦解。像小雷家这样的应该不多。在城市里也开始进行承包制的试点，充分发挥一切调动经济的手段，小平同志的“猫论”由此产生。这一年，新的人生在小宋和雷东宝的面前徐徐拉开了大幕。 《沧桑二十年》第三篇1980年小雷家终于开始改革了。在小宋的帮助下，东宝直接将大队土地包产到户。这是当时政策支持的，但却超出了人们头脑中的□□观念。村里的砖窑也开工了，工作的那30人每月有5、60元的收入，这在当时非常了不起了。（我母亲做20多年教师，当时的收入每月不过69.4元。公婆作为普通工人当时的收入每月才2、30元。）大队的女人们也跟着宋运萍搞起了副业，在家里养长毛兔。一年下来，家家能吃上猪肉了、买自行车了、手里有余钱了。这和一年前相比，简直是天壤之别。有很多年纪小些的mm也许会问，为什么小雷家一年就变化这么大，原来为什么不这样做呢？在以前，农村实行的是工分制。我听下过乡的老同志讲，一天一般记10个工分，只要出勤就有，无所谓工作质量和数量。他们去公社或县里开会，是公差也照样计分。冬天修水库，挖地的和写稿的都算出勤，记一样的分。所以说：“干多干少一个样，干好干坏一个样。”只考虑公平，不考虑效率。到年底的时候，把大队的总收入除以工分总和，得出每分的价值，再乘每个人的工分就是每年的年收入。好的大队一年能有上百元的收入，不好的甚至还有倒扣的。当时也不鼓励副业生产，“以粮为纲，纲举目张”、“宁要社会主义的草、不要资本主义的苗”、“割资本主义尾巴”，把农业生产之外的所有集体经济几乎都禁止了，同时也不允许农民的个体经济。甚至连自留地里生产的产品不允许交易。我们小的时候就上街去抓过买葵花子的，因为那是“资本主义的尾巴”。可见，这种生产方式严重压抑了人们的劳动积极性，造成社会生产力低下。和这些旧的相比，小雷家的新举措自然极大地调动了人们的积极性，人们的劳动可以直接为个人和家庭带来收益，多年被压抑的热情一下子迸发出来，人们看到了生活的希望。从这个角度分析，小雷家的成绩就可以理解了。但不都是像小雷家这样共同富裕。很多地方分地以后，集体经济被极度弱化，干部们也埋头于自己的田地，放弃了集体的工作。小雷家比较幸运，小宋和徐县长的及时指点，让掌舵人东宝不仅为个人发财兴奋，也为集体发展做出了谋划，这为未来的集体经济发展奠定了基础。小雷家从一开始就按照市场经济的原则运作：价格制定机制灵活，无须向上级申报审批，自定价格，比国营砖厂便宜2厘钱；接受预付费的方式，解决资金问题；注意市场宣传，由老书记带人走遍各乡村推广产品；这些措施使小雷家的红砖迅速打开并占领市场，为集体经济完成了第一次原始积累。 梁思申的外祖父从美国回来了，79年中美建交，坚冰被融化，民间交往开始增加，这是中国对外开放的标志性事件之一。随之而来，梁出国留学，为小宋打开了观察世界的一个窗口，也为他架起一座通向世界的桥梁。小宋看了电影《小花》，这是新时期文艺繁荣的标志，而《追捕》则是从发达国家引进的第一部电影，正常的文化交流恢复了，人们终于有了样板戏之外的娱乐。年底，对□□和□□反党集团的审判，是社会走向法制的标志。即使是政敌，也不再采用政治批判的手段，用法律来审判，这在当时是令人们震撼的。全国的电视转播和媒体铺天盖地的报道，使老猢狲之流的造反派知道，他们的时代一去不复返了。 《沧桑二十年》第四篇1982年这一年，东宝和小宋的命运都迎来了转折。小雷家的外部环境呼啦啦就发生了改变。从宏观环境上说，包产到户不再仅仅是理论和实践的探讨，获得了中央文件的明确支持。（悲哀一下：明明用眼睛可以看到的成绩，没有那纸红头文件，就始终上不得台面。）而微观环境，提拔任用年轻干部的政策也落实到县里，小雷家的靠山徐县长变成了徐书记。擅长政治投机的陈平原将小雷家推举为全县改革开放的旗帜，小雷家和东宝得到了他们原来没敢想的荣誉，也得到了梦想中的各种支持，小雷家的路更宽了。小宋毕业了，他怀揣着雄心勃勃、大展拳脚的理想，从平静的校园走进了现实的社会生活。但现实与理想间永远存在差距，令他没想到的，刚进入金州这个国营大企业，就陷入了人事斗争的泥潭。年初，中央下发了《国营工厂厂长工作暂行条列》，明确规定厂长对工厂的经营活动行使统一指挥权，也就是人们所说的厂长负责制。工厂的领导权从政工干部——书记的手中转移到管理干部——厂长的手中，这意味着工厂的生产经营职能上升为第一位。这种权力的转移在很多企业都伴随着激烈的人事斗争，书记们通常不愿意主动放弃手中的权力，金州亦如此。在同一个条例中，还有这样的规定：“厂长要自觉接受和维护企业党委的领导，定期向党委汇报工作，定期向职工代表大会报告工作；对厂长的奖惩，应通过职工代表大会讨论，按干部管理权限，报上级机关批准。”水书记正是拿着这个条款，或明或暗与费厂长进行权力之争。高层的不合，在下面就会进行所谓的“站队”，你必须要表明你的立场，或支持其中一方，或干脆远离。而小宋，从进入金州的那天起，身上就被贴上了“水书记的人”的标签，即使他不情愿，即使他想远离，甚至即使他对水的做法有反感，都不能改变别人眼中他的立场。令小宋还没想到的是，刘工口中自豪的产能和技术水平，甚至还没有达到国外60年代的水平，原本薄弱的工业基础和十年浩劫的雪上加霜，使我国当时的技术工艺与国外相比有着较大的差距。这里就为小宋日后的技术改造和引进国外设备打下了伏笔，也暗示出小宋的大有作为。水书记对小宋是真的关心（棋手对棋子的关心，车总比卒好用），他明确要求小宋从一线做起，了解基层，不做空中楼阁。争气的小宋对一车间的设备了如指掌，并同工人打成一片，获得工人的拥护，为未来的发展奠定了群众基础。还快，小宋被水提升为一个小小的头目，手下有了2个人。企业的管理逐渐正规化。1月2日，□□中央、□□作出《关于国营工业企业进行全面整顿的决定》。要求从1982年起，用两三年时间，分期分批地对所有国营工业企业进行全面的整顿工作，包括整顿领导班子、职工队伍、管理制度、劳动纪律、财经纪律、党的作风和加强思想政治工作等等，通过全面整顿，逐步地建设起一种又有民主、又有集中的领导体制，一支又红又专的职工队伍和一套科学的管理制度。金州贯彻中央指示成立了整顿办，负责岗位责任制和质量管理工作的推行。中央是希望借此提高企业的管理水平，促进企业发展，可惜好经被下面的歪嘴和尚念差了，整顿办又成了水费权力之争的筹码，唉！81年开始，国家面向居民和单位发行国库券。和以后的争相抢购不同，这时人们对国库券缺少了解和认识，发行主要以摊派为主，雷东宝和小宋他们对此都不感冒。这一年8月，十二大召开。在大会上，□□同志第一次提出“建设有中国特色的社会主义”这一崭新命题，并指出：核心任务是经济建设，它是解决国际国内问题的基础。这件大事虽然我们没在耐宝的笔下看到，但它的影响波及未来。 《沧桑二十年》第五篇1983年这一年的对小雷家是跌宕起伏的。由于妻子的意外去世，徐书记调回北京。临行前，徐将省劳模和市人大代表的荣誉交给了东宝，使小雷家改革旗帜的地位更加稳固了。但随后发生的一件事成了东宝心头永远的痛。由于担心“利改税”后国家政策的变化，市电线厂想把留存的计划外利润花掉盖职工宿舍，但是钱不够。他们挑了一个软柿子，以为小雷家是乡镇企业，不敢把国营企业怎样，骗小雷家为他们带工带料接下这个工程，完成后却赖帐不给。要建设信用社会啊！村民们对集体财产的捍卫、雷东宝的火爆脾气、老猢狲的挑拨，村民们的愤怒燃成了熊熊大火，他们采用的最不理智的讨债方式­——群械。而这种破坏社会安定的行为在任何时候都是不被允许的。让东宝痛心的是他温柔的妻子宋运萍和肚子里的宝宝在这场风波中因意外丧生了。宋运萍的命换来了东宝的免予处分，但东宝身上也被陈平原贴上了“隐患”的标签，被远离和搁置了起来。小雷家的外部环境又一次恶化。（“利改税”背景介绍：新中国成立以来，我国在处理国家与企业分配关系时一直采用利润上缴的方法，即企业把全部的收入上缴国家，企业需要资金，则由预算层层下拨。这种统收统支的分配形式使企业既没有一定的经营自主权，也不承担相应的经济责任。为了改变这种“统收统支，统负盈亏”的分配方法，正确处理国家、企业、个人三者之间的利益关系，同时扩大企业的经营自主权，调动企业、职工的生产积极性，加强企业的经营管理，稳定增加国家财政收入，□□总理于1982年11月30日在五届人大五次会议作的《关于第六个五年计划的报告》中充分肯定了利改税的方向，并把对国营企业逐步推行“以税代利”列为第六个五年计划后三年经济体制改革重点要做的三件事的第一件事。）不屈不挠的讨债精神，使市里不胜其烦，终于将电线厂的一套设备顶给了小雷家，东宝他们不得不接手设备开电线厂。他们从邻市的电线厂找来“星期日工程师”，这是当时比较流行的兼职方式。技术人员利用周末到乡镇企业兼职，赚外快的同时，也帮助乡镇企业解决了很多实际问题，是体制下的“走私”。东宝对这些技术人员礼让有加，赢得了他们的尊重。他们牵线帮助小雷家与邻市电线厂联营。这也是当时很流行的乡镇企业成长之路。因为人们对乡镇企业产品质量的怀疑，逼着很多乡镇企业不得不与国营企业联营，用国营企业的品牌效应推销自己的产品。虽然要将自己的部分利润拱手送给别人，但乡镇企业的产品之路却拓宽了。小雷家和市建二公司也联营了，电线厂的风波带来的乌云终于在他们头顶上散开了。陈平原回头了，10月东宝也随着市里去蛇口参观了。和东宝一样，宋运辉在这一年也是跌宕起伏的。随着费厂长调去党校学习，金州的权力之争暂时告一段落，大权重新回到水书记的手中。水并非仅仅擅长政治斗争的庸才，果真如此他是不可能身居管理高位的。当他重掌大权后，金州的改革一下就顺利铺开了。被金州沉闷气氛压抑的小宋看到工作的希望，奋笔疾书写出自认为完美的工作计划，交给了上级。一句无意中说出的技术观点却被敏感的水抓住，派小宋去北京了解先进的技术动态。这对于小宋是一次转折。在同各有关单位、领导与徐书记的交流中，小宋的视野不再仅仅局限于技术，开始学习从综合的角度思考问题，也为他从技术干部向管理干部转变，避免重蹈刘工覆辙奠定了基础。当小宋带着新技术的信息回到金州，在水的操控下，小宋上上下下被几次折腾。先是被当作枪手将费厂长和刘工的方案全盘否定，助水牢牢掌控金州；随后又被水轻描淡写地奖励，让所有人包括宋自己都以为宋不过是个小角色；当小宋因为心怀不满对水顶撞时，水又出人意料将宋带回家吃饭，表现出与众不同的亲昵；可一句“累不死”又将宋推回一线工作。几番上下，不得不佩服水的手段。既拉拢和使用小宋，又不让小宋尾巴翘上天被众人孤立，拉一把，推一下，胡萝卜加大棒，维持了巧妙的平衡，也使小宋认清了水书记对自己的培养，放下心结，心甘情愿为水工作。高，实在是高。宋的室友寻建祥除了完成工作，整天寻衅滋事，散发过剩精力，是当时所谓“迷惘的一代”的代表。当时，随着改革开放，旧的政治至上的价值观受到严重冲击，□□期间人们信仰的、崇拜的被批判和推翻，而新的价值观尚未建立，社会上论资排辈的现象也十分严重。很多青年人看不到前途，找不到方向，陷入迷茫。在实践中则表现为，无政府主义抬头，各地犯罪率都有所上升，恶性案件也时有发生。8月，中央发出“严打”指示，要求对各种犯罪行为“从重从快，一网打尽”，所谓“乱世用重典”。这次严打明显呈现扩大化趋势，不该抓的抓了，不该判的判了，该判轻的判重了，一时间，监满为患，好多犯人被送往新疆。寻建祥一次打架斗殴，被判10年并送往新疆，人生轨迹被改变了。（这一年的严打，最快的几天就判刑，缺少必要的审判程序，人为的因素非常浓。基本上天天可以看到打着红叉的判决书贴在大街上，我们也参加过多次公判大会。）这一年□□思潮又有所抬头，突出表现在以批判“资产阶级自由化思潮”为代表的整党运动，批判人的“异化”理论，清除所谓“精神污染”。这是□□后的第一次整党，很多人习惯性地沿用了□□的大批判手法，虞山卿就利用这个机会成功上位，将原来发展势头比自己强的宋运辉拉下马来。当，当，当，第三主角出场。国庆节放假的时候，小宋在家里遇见了杨巡。代表国营经济的宋运辉，代表乡镇集体经济的雷东宝，代表个体私营经济的杨巡，他们会有着怎样不同的发展道路呢？让我们试目以待。 《沧桑二十年》第六篇1984年当老徐开始思考能人和集体的关系时，我们在心里为东宝担了份忧：发展顺利、自大、刚愎的东宝会有事吗？现在还没看到，但我们看到了他的行为：为了猪场强行填了雷忠富的鱼塘，是为了集体利益可也损害了合同的权威性。在这件事上，我的评价很矛盾：东宝为了全村人的利益牺牲了雷忠富的利益，按照少数服从多数的原则，东宝是正确的；但白纸黑字的合同就这样因一人之言而作废，法律的尊严又在哪里？如果忠福不是向上级告状，直接一纸诉状将小雷家和东宝告上法庭，又会是什么结果？或者县里不是支持他的陈平原当政，换成有心抓他把柄的别人又会怎样？集体的发展一定要牺牲个人利益吗？好在忠富看到养猪场的前景，对东宝心服口服，再没起大波澜。可是，下次与法律相悖的事，东宝还会顺利吗？在80年代初期，乡镇企业起步阶段，由于认识的差距、成本的考虑，环保问题并未提上议事日程。当走在技术前沿的小宋就环保问题与东宝发生争执的时候，更高屋建瓴的老徐没提出这个问题，东宝请来的专家也没提出这个问题，小雷家的当家人东宝就更不在乎了。在东宝的眼里，成本和市场才是重要的问题，至于环保，农民们有钱挣，谁考虑那些。正是这些来自领导层、管理层、技术层当年的不在乎、无所谓，酿成了今天中国的环境现状。也许我们可以说：先发展，后环保，但是环境恶化的苦果终究还是要我们自己吞下，孰轻孰重，孰重孰轻，回头看，又有几人能做出不一样的选择。在前一年底，虞山卿利用整党的机会，让小宋因寻建祥而背上污点。过了年在涉及到与外方谈判时，在这个依然重视政治可靠的年代，小宋就因这个污点政审不合格被虞替代了。虞的心机在这里显现无余。可虞的这种心机很容易让人一眼看透而不屑。上大学时，曾有老师评价一名同学：所有的聪明都写在脸上，让人不得不防。当小宋明白这一切时，他利用程开颜散布流言，逼刘工大义灭亲，用扎实的英语功底打败了虞，成功翻身。虞的心机是用踩人的办法，这种办法有用却遭人鄙夷，宋的心机是利用小程的仰慕小小的设计了一下，神不知鬼不觉，手段自然比虞要高许多，既达成目的又没有树立敌人。但是，后来在程厂长的指点下，小宋也了解了作为上位者是离不开虞这种听话好用的机会主义者的，这是后话了。刘工在小宋的心中地位坍塌了。从刚进厂时得到刘工笔记本的帮助，视刘工为偶像；到水书记为小宋掰章，了解刘工的破坏性；再到虞山卿这件事让小宋了解刘工的普通人性，偶像破灭的过程，实际也是小宋成长的过程。我们刚一接触社会的时候，总是仰视前辈和权威，把他们放在高不可攀的位置。可随着自身的成熟，与偶像的了解、接触之后，偶像们又会被我们自己放回到地面，这是我们必经的阶段。随着设备引进协议的签订，小宋被派到德国验收设备。在这里他接触到严谨规范的德式管理，虚心求学的他在管理知识方面从小梁寄来的书本知识上升为实践，更上层楼。小宋在每一次机遇中快速成长，让我们不得不预见他的未来不可限量。设备运回国来，小宋投入了紧张的安装调试工作。在工作过程中，小宋发现了精神激励的作用，原本不善言辞的他学会了用语言、工作气氛等手段调动大家的积极性，哈哈，赫茨伯格“双因素论”在实践中的具体应用。小宋在程厂长的支持下，用“我把青春献给党”、学习女排精神、“拼搏最后一百天”、火线入党等手段，充分调动了青年工人的积极性，使他们找到工作目标，为解决寻建祥一类的问题找到办法，也为水书记提供的新闻宣传的角度。水在向部里和媒体推介小宋的同时，也在宣传自己的政绩，小宋的功绩背后自然包含着水的慧眼识人。当新设备运转成功后，毕业刚满2年的小宋被任命为新车间的副主任。干得好，小宋。让我们期待他的未来发展吧。 《沧桑二十年》第七篇1985年代表个体经济的小杨巡再次登场，他和弟弟挑担上东北，开始了自己闯关东的生活。和相对保守的东北人不同，一些头脑活络的江浙人跟随他们敏锐的市场嗅觉，已经在东北找到自己的市场，开始扎根了。小杨并非先行者，又没有多少钱，但他年轻又不怕吃苦，这就是他的资本。他让弟弟给别人守柜台，自己上门推销，很快手里掌握了长长的客户名单。当年后小杨回家时，他已经可以成为小雷家的大客户了。当小杨来到小雷家，游商的本性又发作了。他要求小雷家为他定制缺斤短两的电线，东宝虽然答应了，心中却充满了鄙夷。个体经济发展中，确实有不少人挣过这种黑心钱。不管怎么说，小杨短短的时间就发展起来了，人送称号：小杨倒爷。倒爷是当时人们对那些将物资四处贩运的人的称呼，算尊称，可也还是没脱离人们心中投机倒把的不良印象。和小宋相比，东宝的发展道路上充满坎坷。当小雷家的经济走上正轨的时候，东宝的提携人老支书却爆出了贪污问题。（我从来不相信人之初性本善，我相信人的本性是自私的。所以贪污的问题天生就包含在人的本性中，做与不做取决于后天的教育和制度的监督。我们不应该寄希望于人们的天性纯良，必须用制度去规范、用道德去约束，其中有效的监督是不可缺少的环节。）东宝对老支书给予了充分的信任，但老支书恰恰冒用了这份信任，没有抵制住钱的诱惑。但事情的发展又出乎东宝的预料，老支书自杀了。人的劣根性在小雷家村民身上显现无余。当老支书家人撒泼打赖时，人们只是旁观；可是当审查结果公布时，村民们看到自己的利益被侵蚀了，又不顾老支书家人的感受了，总是将自身的利益放在第一位，再次证明人是自私的。老支书这件事让东宝感到正规管理的必要性，而小宋看了大量的管理书籍后却在金州僵化的体制下无用武之地，两下一拍即合。在激烈的讨论后，他们为小雷家制定了既符合现代管理规则，又符合小雷家实际情况的管理模式。可是这个管理模式拿到县里审批时却遭到诸多非议，责问的中心问题都集中在分配制度上。这时的人们还是大锅饭的思维方式，虽然理论上一直在讲社会主义的分配制度是“按劳分配、多劳多得”，可实际上人们对体制内的分配一直还是抱着平均主义的想法。幸运的是，在陈平原的支持下，小雷家的机构架设终于通过了，小雷家的发展进一步规范化。这一年，作为重要生活物资的生猪价格放开，这是价格体制松动的标志，小雷家的几千头猪就意味着更多的盈利了。和蓬勃发展的小雷家不同，作为国营大厂的金州改革步伐仍然步履蹒跚。由于新设备能耗较大，高质量的产品却鸡蛋卖出土豆价，没能体现优势，水书记被部里批评了。这时的国家政策对金州这类大型企业实行统购统销政策，也就是说，企业并没有定价权和销售权，国家统一定价，统一收购，统一调配，完全的计划经济模式。市场是小雷家和杨巡的命脉，却与金州毫无瓜葛，所以才会出现新车间的高品质产品和老车间的产品一个价的怪现象。面对部里的压力，水书记要求小宋降低能耗而不必考虑质量，小宋不甘心明珠暗投，利用年初的文件，和水、程共同商讨了申请价格双轨制和出口自营权作为新车间的新出路。和早在83年某水泥厂就执行价格双轨制相比，金州已经大大落后了，可水书记在部里仍被冠以“改革先锋”的头衔。同样是国营企业，国家水泥厂等小型企业的管治相对宽松，而金州这类大型企业则被国家严格控制，金州在改革开放中宛若置身世外，不理俗事。在水书记在部里斡旋的时候，小宋和顶头上司一分厂厂长的矛盾却尖锐化了。擅长技术的小宋把新车间牢牢掌握在手中，惹恼了他的上司。谁也不是省油的灯，一分厂厂长直接将矛盾上交宋的岳父程厂长，宋被闲置，赢得了舆论的同情，一分厂厂长却别形容成小肚鸡肠不容人的形象，在群众眼里失了分，只有手段更高超的水书记看到了小宋的明修栈道暗度陈仓。当金州的出口自营权被批准时，小宋走马上任，新的天地又在小宋面前拉开。]]></content>
      <categories>
        <category>随笔</category>
        <category>大江东去</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>喜欢的书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F18%2Fhexo%E5%AE%98%E6%96%B9hello-world%E6%96%87%E7%AB%A0%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo官方文章示例</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
